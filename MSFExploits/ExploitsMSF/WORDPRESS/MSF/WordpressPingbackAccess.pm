package MSFExploits::Exploits::WORDPRESS::MSF::WordpressPingbackAccess;
# use parent qw(MSFExploits::Exploit MSFExploits::Services::WORDPRESS);

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use URI::URL;
use Data::Dump qw(dump);
use Coro qw( async );

# # use MSFExploits::Functions::Basic;
# # use MSFExploits::Functions::Errors;
# # use MSFExploits::Functions::Content;

sub load {
    my $type  = shift;
    my $class = ref $type || $type;
    my $self = { };
    bless $self, $class;

    return $self;
}

sub new {
   my $class = shift;
   my ( $requester, $database ) = @_;

   my $name = "WordpressPingbackAccess";

   my $DETECTION = {

   };

my $EXPLOIT = {
  DESCRIPTION => "

          This module will scan for wordpress sites with the Pingback

          API enabled. By interfacing with the API an attacker can cause

          the wordpress site to port scan an external target and return

          results. Refer to the wordpress_pingback_portscanner module.

          This issue was fixed in wordpress 3.5.1

        ",
  METHOD      => "POST",
  MSF_MODULE  => "wordpress_pingback_access",
  PATH        => "__URI__?",
  PATHS       => ["__URI__", ""],
  PAYLOAD     => "",
  REFERENCES  => [
                   "http://www.securityfocus.com/archive/1/525045/30/30/threaded",
                   "http://www.ethicalhack3r.co.uk/security/introduction-to-the-wordpress-xml-rpc-api/",
                   "https://github.com/FireFart/WordpressPingbackPortScanner",
                 ],
  TITLE       => "Wordpress Pingback Locator",
  VARIABLES => {
    'URI' =>       { DESCRIPTION => "", VALUE => "" },
    'PINGBACK_XML' =>       { DESCRIPTION => "", VALUE => "" },
    'PATH' =>       {
  DESCRIPTION => "The path to wordpress installation (e.g. /wordpress/)",
  VALUE => "/",
},
  },

  TYPE => 'MSF',
  PLATFORM => 'SCANNER',
  REQUESTS => {
    EXPLOIT2 => {
      METHOD       => 'GET',
      PATH   => '',
      PAYLOAD      => '',
      TEXT   => 'Sending Exploit #2 Request : [GET] ',
      HEADERS      => {
        'Content-Type' => 'application/x-www-form-urlencoded',
      },
      VALIDATION   => {
        TCODE => ['200'],
      },
    },
  },
   };

   return $class->SUPER::new($requester, $database, $name, $DETECTION, $EXPLOIT, @_);
}

return 1;
