package Base;

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use FindBin qw {$RealBin $RealScript};
use File::Spec::Functions;
use Data::Dump qw(dump);
use Scalar::Util qw/reftype/;
use LWP::UserAgent;

my $envDebug = 0;

sub Version {
    return("2.8-dev");
}

sub new {
    my $class = shift;
    my $hash = @_ ? shift : { };
    my $self = bless($hash, $class);
    
    return($self);
}

sub Requester {
    my $self = shift;
    $Base::Requester = shift if(@_);
    $Base::Requester = LWP::UserAgent->new() if(!defined($Base::Requester));
    
    return $Base::Requester;
}

sub Webdriver {
    my $self = shift;
    $Base::Webdriver = shift if(@_);
#    $Base::Webdriver = Webdriver->new('phantomjs', 'phantomjs', 0) if(!defined($Base::Webdriver));
    
    return $Base::Webdriver;
}

sub Logger {
    my $self = shift;
    
    $Base::Logger = shift if(@_);
    
    return $Base::Logger;
}

sub DNS {
    my $self = shift;
    $Base::DNS = shift if(@_);
#    $Base::DNS = DNS->new() if(!defined($Base::DNS));
    
    return $Base::DNS;
}

sub Database {
    my $self = shift;
    $Base::Database = shift if(@_);
    
    return $Base::Database;
}

sub Configuration {
    my $self = shift;
    $Base::Configuration = shift if(@_);
#    $Base::Configuration = Configuration->new() if(!defined($Base::Configuration));

    return $Base::Configuration;
}

sub Arguments {
    my $self = shift;
    $Base::Arguments = shift if(@_);
    $Base::Arguments = {} if(!defined($Base::Arguments));

    return $Base::Arguments;
}

sub _Targets {
    my $self = shift;
    $Base::Targets = shift if(@_);
    $Base::Targets = { } if(!defined($Base::Targets));
    return($Base::Targets);
}

sub _Env {
    my $self = shift;
    $Base::Env = shift if(@_);
    $Base::Env = { } if(!defined($Base::Env));
    return($Base::Env);
}

sub _TempEnv {
    my $self = shift;
    $Base::TempEnv = shift if(@_);
    $Base::TempEnv = { } if(!defined($Base::TempEnv));
    return($Base::TempEnv);
}

sub _TempEnvs {
    my $self = shift;
    $Base::TempEnvs = shift if(@_);
    $Base::TempEnvs = { } if(!defined($Base::TempEnvs));
    return($Base::TempEnvs);
}

sub _Error {
    my $self = shift;
    $self->{'Error'} = shift if(@_);
    return($self->{'Error'});
}

# Print Function Overrides
sub _OverridePrint {
    my $self = shift;
    $Base::_OverridePrint = shift if(@_);
    return($Base::_OverridePrint);
}
sub _OverridePrintStderr {
    my $self = shift;
    $Base::_OverridePrintStderr = shift if(@_);
    return($Base::_OverridePrintStderr);
}
sub _OverridePrintLine {
    my $self = shift;
    $Base::_OverridePrintLine = shift if(@_);
    return($Base::_OverridePrintLine);
}
sub _OverridePrintDebug {
    my $self = shift;
    $Base::_OverridePrintDebug = shift if(@_);
    return($Base::_OverridePrintDebug);
}
sub _OverridePrintDebugLine {
    my $self = shift;
    $Base::_OverridePrintDebugLine = shift if(@_);
    return($Base::_OverridePrintDebugLine);
}
sub _OverrideError {
    my $self = shift;
    $Base::_OverrideError = shift if(@_);
    return($Base::_OverrideError);
}
sub _OverrideerrorLine {
    my $self = shift;
    $Base::_OverrideerrorLine = shift if(@_);
    return($Base::_OverrideerrorLine);
}

sub showVariables {
    my ( $self ) = @_;
    
    foreach my $key (sort keys %{ $self->_Env }) {
        my $value = $self->_Env->{$key};
        print "$key => $value\n";
    }
    
}

sub addTarget {
    my ( $self, $target ) = @_;
    
    if($target && $target->{domain}) {
        $target->{data_directory} = $self->_Env->{WEBUI_TARGETS_DIRECTORY} . '/' . $target->{domain} or die("Missing targets directory setting\n");
        $self->_Targets->{$target->{domain}} = $target;
        create_directory($target->{data_directory});
    }
    
}

sub getTarget {
    my ( $self, $target_domain ) = @_;
    my $target = 0;
    
    if(defined($self->_Targets->{$target_domain})) {
        $target = $self->_Targets->{$target_domain};
    }
    
    return $target;
}

sub getEnv {
    my $self = shift;
    my $key = shift;
    my @envs = ($self->getTempEnv, $self->getGlobalEnv);
    print join(' ', caller()) if($envDebug >= 3);
    # fixme more than two envs...
    return($self->mergeHash ($envs[0], $envs[1])) if(!defined($key));
    
    foreach my $env (@envs) {
        if(exists($env->{$key})) {
            print "Get $key => " . $env->{$key} . "\n" if($envDebug);
            return($env->{$key});
        }
        
        # Case insensitive matching for the newbies/typos
        foreach my $ekey (keys(%{$env})) {
            if (lc($ekey) eq lc($key)) {
                print STDERR "[*] WARNING: the correct case of the '$ekey' variable is '$key'\n";
                $env->{$key} = $env->{$ekey};
                delete($env->{$ekey});
                return $env->{$key};
            }
        }
    }
    
    
    return;
}


# Global Environment
sub getGlobalEnv {
    my $self = shift;
    my $key = shift;
    my $env = $self->_Env;
    print join(' ', caller()) if($envDebug >= 3);
    if(defined($key)) {
        print "GetGlobal $key => " . $env->{$key} . "\n" if($envDebug);
        return($env->{$key});
    }
    
    return($env);
}

sub setGlobalEnv {
    my $self = shift;
    my @pairs = @_;
    
    my $env = $self->_Env;
    
    for(my $i = 0; $i < @pairs; $i += 2) {
        if ($pairs[$i] =~ /^socks/) {
            Pex::Socket::socks_setup($pairs[$i], $pairs[$i + 1]);
        }
        print "SetGlobal $pairs[$i] => " . $pairs[$i + 1] . "\n" if($envDebug);
        $env->{$pairs[$i]} = $pairs[$i + 1];
    }
    return($env);
}

sub unsetGlobalEnv {
    my $self = shift;
    my $key = shift;
    if(!defined($key)) {
        $self->_Env({ });
    }
    else {
        delete($self->_Env->{$key});
    }
}

# Temporary Environment
sub getTempEnv {
    my $self = shift;
    my $key = shift;
    my $env = $self->_TempEnv;
    if(defined($key)) {
        print "TempGet $key => " . $env->{$key} . "\n" if($envDebug);
        return($env->{$key});
    }
    return($env);
}

sub setTempEnv {
    my $self = shift;
    my @pairs = @_;
    
    my $env = $self->_TempEnv;
    
    for(my $i = 0; $i < @pairs; $i += 2) {
        print "TempSet $pairs[$i] => " . $pairs[$i + 1] . "\n" if($envDebug);
        $env->{$pairs[$i]} = $pairs[$i + 1];
    }
    return($env);
}

sub unsetTempEnv {
    my $self = shift;
    my $key = shift;
    print "UnsetTempEnv $key\n" if($envDebug);
    if(!defined($key)) {
        $self->_TempEnv({ });
    }
    else {
        delete($self->_TempEnv->{$key});
    }
}

sub getSavedTempEnv {
    my $self = shift;
    my $envName = shift;
    my $key = shift;
    my $env = $self->_TempEnvs->{$envName};
    return if(!defined($env));
    if(defined($key)) {
        print "TempGet $key => " . $env->{$key} . "\n" if($envDebug);
        return($env->{$key});
    }
    return($env);
}

sub setSavedTempEnv {
    my $self = shift;
    my $envName = shift;
    my @pairs = @_;
    
    # Create it if it doesn't exist
    $self->_TempEnvs->{$envName} = { } if(!defined($self->_TempEnvs->{$envName}));
    my $env = $self->_TempEnvs->{$envName};
    
    for(my $i = 0; $i < @pairs; $i += 2) {
        print "TempSet $pairs[$i] => " . $pairs[$i + 1] . "\n" if($envDebug);
        $env->{$pairs[$i]} = $pairs[$i + 1];
    }
    return($env);
}

sub deleteTempEnv {
    my $self = shift;
    my $key = shift;
    if(!defined($key)) {
        $self->_TempEnvs({ });
        $self->_TempEnv({ });
    }
    else {
        delete($self->_TempEnvs->{$key});
    }
}

sub getTempEnvs {
    my $self = shift;
    return($self->_TempEnvs);
}

sub saveTempEnv {
    my $self = shift;
    my $name = shift;
    print "SaveTempEnv $name\n" if($envDebug);
    my %copy = %{$self->_TempEnv};
    $self->_TempEnvs->{$name} = \%copy;
}

# fixme LoadTempEnv doesn't make a copy, so you are modifing the saved copy...
sub loadTempEnv {
    my $self = shift;
    my $name = shift;
    print "LoadTempEnv $name\n" if($envDebug);
    $self->_TempEnv($self->_TempEnvs->{$name});
    return($self->_TempEnv);
}

# Error Code
sub IsError {
    my $self = shift;
    return(defined($self->getError));
}
sub getError {
    my $self = shift;
    return($self->_Error);
}
sub setError {
    my $self = shift;
    my $error = shift;
    $self->_Error($error);
    return($error);
}
sub clearError {
    my $self = shift;
    $self->_Error(undef);
}

sub printError {
    my $self = shift;
    my $error = $self->_Error;
    return(0) if(!$self->IsError);
    
    if ($error) {
        $self->printLine("Error: $error");
    }
    
    $self->clearError();
    return(1);
}

# Print Foo
sub Print {
    my $self = shift;
    my @args = @_;
    if(defined($self->_OverridePrint)) {
        return(&{$self->_OverridePrint}($self, @args));
    }
    $args[0] =~ s/\e/\[ESC\]/g;
    print STDOUT @args;
}

sub printStderr {
    my $self = shift;
    my @args = @_;
    if(defined($self->_OverridePrintStderr)) {
        return(&{$self->_OverridePrintStderr}($self, @args));
    }
    $args[0] =~ s/\e/\[ESC\]/g;
    print STDERR @args;
}

sub printLine {
    my $self = shift;
    if(defined($self->_OverridePrintLine)) {
        return(&{$self->_OverridePrintLine}($self, @_));
    }
    
    $self->Print(@_, "\n");
}

sub printDebug {
    my $self = shift;
    my $level = shift;

    if(defined($self->_OverridePrintDebug)) {
        return(&{$self->_OverridePrintDebug()}($self, $level. @_));
    }
    $self->printStderr(@_) if(defined($self->getGlobalEnv("DEBUG")) >= $level);
}
sub printDebugLine {
    my $self = shift;
    my $level = shift;
    if(defined($self->_OverridePrintDebugLine)) {
        return(&{$self->_OverridePrintDebugLine}($self, $level, @_));
    }
    $self->printDebug($level, @_, "\n");
}

sub PrintError {
    my $self = shift;
    if(defined($self->_OverrideError)) {
        return(&{$self->_OverrideError}($self, @_));
    }
    $self->Print(@_);
}

sub errorLine {
    my $self = shift;
    if(defined($self->_OverrideerrorLine)) {
        return(&{$self->_OverrideerrorLine}($self, @_));
    }
    $self->printLine(@_);
}

# Other stuff
sub debugLevel  {
    my $self = shift;
    return($self->getEnv('debugLevel'));
}

sub mergeHash  {
    my $self = shift;
    my $hash1 = shift || { };
    my $hash2 = shift || { };
    my %hash = %{$hash1};
    foreach (keys(%{$hash2})) {
        if(!defined($hash1->{$_})) {
            $hash{$_} = $hash2->{$_};
        }
    }
    return(\%hash);
}

sub mergeHashRec {
    my $self = shift;
    my $hash1 = shift || { };
    my $hash2 = shift || { };
    my %hash = %{$hash1};
    foreach (keys(%{$hash2})) {
        if(!defined($hash1->{$_})) {
            $hash{$_} = $hash2->{$_};
        }
        # recurse if both are hash refs
        elsif(ref($hash1->{$_}) eq 'HASH' && ref($hash2->{$_}) eq 'HASH') {
            $hash{$_} = $self->mergeHashRec($hash1->{$_}, $hash2->{$_});
        }
        # recurse if both are array refs
        elsif(ref($hash1->{$_}) eq 'ARRAY' && ref($hash2->{$_}) eq 'ARRAY') {
            my @res = @{$hash1->{$_}};
            foreach my $kval (@{$hash2->{$_}}) {
                if(ref($kval) || !arrayContains(\@res, [ $kval ])) {
                    push(@res, $kval);
                }
            }
            $hash{$_} = [ @res ];
        }
    }
    return(\%hash);
}

sub selfName {
    my $self = shift;
    return($self->moduleName($self));
}

sub selfEndName {
    my $self = shift;
    return($self->moduleEndName($self));
}

sub moduleName {
    my $self = shift;
    my $module = shift;
    my ($name) = split('=HASH', $module);
    return($name);
}

sub moduleEndName {
    my $self = shift;
    my $module = shift;
    my $name = $self->moduleName($module);
    my @parts = split('::', $name);
    return($parts[-1]);
}

sub scriptPath {
    my $self = shift;
    return "$RealBin/$RealScript";
}

sub scriptBase {
    my $Self = shift;
    return "$RealBin/../";
}

1;
