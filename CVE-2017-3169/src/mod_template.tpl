
/*
 * Compilation : apxs -i -a -c __MODULE-NAME__.c
 */

#include "httpd.h"
#include "http_core.h"
#include "http_protocol.h"
#include "http_request.h"
#include "http_connection.h"
#include "ap_config.h"

#include "apr_strings.h"
#include "apr_version.h"

#define MAX_HANDLER 4
#define TRACE_NOTE "__NAME__-hooks-trace"
#define CONN_NOTE "__NAME__-hooks-connection"

typedef int (*method_handler)(request_rec *r);

static int get_handler(request_rec *r);
static int post_handler(request_rec *r);
static int put_handler(request_rec *r);
static int delete_handler(request_rec *r);

module AP_MODULE_DECLARE_DATA __NAME___module;


/*
 * Sample configuration record.  Used for both per-directory and per-server
 * configuration data.
 *
 * It's perfectly reasonable to have two different structures for the two
 * different environments.  The same command handlers will be called for
 * both, though, so the handlers need to be able to tell them apart.  One
 * possibility is for both structures to start with an int which is 0 for
 * one and 1 for the other.
 *
 * Note that while the per-directory and per-server configuration records are
 * available to most of the module handlers, they should be treated as
 * READ-ONLY by all except the command and merge handlers.  Sometimes handlers
 * are handed a record that applies to the current location by implication or
 * inheritance, and modifying it will change the rules for other locations.
 */
typedef struct x_cfg {
    int cmode;                  /* Environment to which record applies
    * (directory, server, or combination).
    */
    #define CONFIG_MODE_SERVER 1
    #define CONFIG_MODE_DIRECTORY 2
    #define CONFIG_MODE_COMBO 3     /* Shouldn't ever happen. */
    int local;                  /* Boolean: "Example" directive declared
    * here?
    */
    int congenital;             /* Boolean: did we inherit an "Example"? */
    char *trace;                /* Pointer to trace string. */
    char *loc;                  /* Location to which this record applies. */
} x_cfg;

static x_cfg *our_dconfig(const request_rec *r)
{
    return (x_cfg *) ap_get_module_config(r->per_dir_config, &__NAME___module);
}

/*
 * The following utility routines are not used in the module. Don't
 * compile them so -Wall doesn't complain about functions that are
 * defined but not used.
 */
#if 0
/*
 * Locate our server configuration record for the specified server.
 */
static x_cfg *our_sconfig(const server_rec *s)
{
    return (x_cfg *) ap_get_module_config(s->module_config, &__NAME___module);
}

/*
 * Likewise for our configuration record for the specified request.
 */
static x_cfg *our_rconfig(const request_rec *r)
{
    return (x_cfg *) ap_get_module_config(r->request_config, &__NAME___module);
}
#endif /* if 0 */

/*
 * Likewise for our configuration record for a connection.
 */
static x_cfg *our_cconfig(const conn_rec *c)
{
    return (x_cfg *) ap_get_module_config(c->conn_config, &__NAME___module);
}



/*
 * String pointer to hold the startup trace. No harm working with a global until
 * the server is (may be) multi-threaded.
 */
static const char *trace = NULL;

static void trace_connection(conn_rec *c, const char *note)
{
    const char *trace_copy, *sofar;
    char *addon, *where;
    void *data;
    x_cfg *cfg;
    
    #if EXAMPLE_LOG_EACH
    example_log_each(c->pool, c->base_server, note);
    #endif
    
    cfg = our_cconfig(c);
    
    where = (cfg != NULL) ? cfg->loc : "nowhere";
    where = (where != NULL) ? where : "";
    
    addon = apr_pstrcat(c->pool,
                        "   <li>\n"
                        "    <dl>\n"
                        "     <dt><samp>", note, "</samp></dt>\n"
                        "     <dd><samp>[", where, "]</samp></dd>\n"
                        "    </dl>\n"
                        "   </li>\n",
                        NULL);
    
    /* Find existing notes and copy */
    apr_pool_userdata_get(&data, CONN_NOTE, c->pool);
    sofar = (data == NULL) ? "" : (const char *) data;
    
    /* Tack addon onto copy */
    trace_copy = apr_pstrcat(c->pool, sofar, addon, NULL);
    
    /*
     * Stash copy back into pool notes.  This call has a cleanup
     * parameter, but we're not using it because the string has been
     * allocated from that same pool.  There is also an unused return
     * value: we have nowhere to communicate any error that might
     * occur, and will have to check for the existence of this data on
     * the other end.
     */
    apr_pool_userdata_set((const void *) trace_copy, CONN_NOTE,
                          NULL, c->pool);
}

static void trace_request(const request_rec *r, const char *note)
{
    const char *trace_copy, *sofar;
    char *addon, *where;
    x_cfg *cfg;
    
    #if EXAMPLE_LOG_EACH
    example_log_each(r->pool, r->server, note);
    #endif
    
    if ((sofar = apr_table_get(r->notes, TRACE_NOTE)) == NULL) {
        sofar = "";
    }
    
    cfg = our_dconfig(r);
    
    where = (cfg != NULL) ? cfg->loc : "nowhere";
    where = (where != NULL) ? where : "";
    
    addon = apr_pstrcat(r->pool,
                        "   <li>\n"
                        "    <dl>\n"
                        "     <dt><samp>", note, "</samp></dt>\n"
                        "     <dd><samp>[", where, "]</samp></dd>\n"
                        "    </dl>\n"
                        "   </li>\n",
                        NULL);
    
    trace_copy = apr_pstrcat(r->pool, sofar, addon, NULL);
    apr_table_set(r->notes, TRACE_NOTE, trace_copy);
}



/* The sample content handler */
static int __NAME___handler(request_rec *r)
{
    x_cfg *dcfg;
    char *note;
    void *conn_data;
    
    dcfg = our_dconfig(r);
    /*
     * Add our trace to the log, and whether we get to write
     * content for this request.
     */
    note = apr_pstrcat(r->pool, "x_handler(), handler is \"",
                       r->handler, "\"", NULL);
    trace_request(r, note);
    
    
    note = apr_pstrcat(r->pool, "x_handler(), handler is \"",
                       r->handler, "\"", NULL);
    trace_request(r, note);
    
    ap_set_content_type(r, "__CONTENT-TYPE__");

    /* method: 0 - GET, 1 - PUT, 2 - POST, 3 - DELETE, etc */
    method_handler methods[MAX_HANDLER] = { &get_handler, &put_handler, &post_handler, &delete_handler };
    
    if (r->method_number >= MAX_HANDLER || r->method_number < 0) {
        return DECLINED;
    }

    /* call the handler function */
    return methods[r->method_number](r);
}


/* GET */
static int get_handler(request_rec *r)
{
   apr_status_t status;
   char* query = r->args; /* query string */
   
   ap_set_content_type(r, "__CONTENT-TYPE__");
   ap_rputs(DOCTYPE_HTML_3_2, r);
   ap_rputs("<HTML>\n", r);
   ap_rputs(" <HEAD>\n", r);
   ap_rputs("  <TITLE>mod_example_hooks Module Content-Handler Output\n", r);
   ap_rputs("  </TITLE>\n", r);
   ap_rputs(" </HEAD>\n", r);
   ap_rputs(" <BODY>\n", r);
   ap_rputs("  <H1><SAMP>mod_example_hooks</SAMP> Module Content-Handler Output\n", r);
   ap_rputs("  </H1>\n", r);
   ap_rputs("  <P>\n", r);
   ap_rprintf(r, "  Apache HTTP Server version: \"%s\"\n",
              ap_get_server_banner());
   ap_rputs("  <BR>\n", r);
   ap_rprintf(r, "  Server built: \"%s\"\n", ap_get_server_built());
   ap_rputs("  </P>\n", r);
   ap_rputs("  <P>\n", r);
   ap_rputs("  The format for the callback trace is:\n", r);
   ap_rputs("  </P>\n", r);
   ap_rputs("  <DL>\n", r);
   ap_rputs("   <DT><EM>n</EM>.<SAMP>&lt;routine-name&gt;", r);
   ap_rputs("(&lt;routine-data&gt;)</SAMP>\n", r);
   ap_rputs("   </DT>\n", r);
   ap_rputs("   <DD><SAMP>[&lt;applies-to&gt;]</SAMP>\n", r);
   ap_rputs("   </DD>\n", r);
   ap_rputs("  </DL>\n", r);
   ap_rputs("  <P>\n", r);
   ap_rputs("  The <SAMP>&lt;routine-data&gt;</SAMP> is supplied by\n", r);
   ap_rputs("  the routine when it requests the trace,\n", r);
   ap_rputs("  and the <SAMP>&lt;applies-to&gt;</SAMP> is extracted\n", r);
   ap_rputs("  from the configuration record at the time of the trace.\n", r);
   ap_rputs("  <STRONG>SVR()</STRONG> indicates a server environment\n", r);
   ap_rputs("  (blank means the main or default server, otherwise it's\n", r);
   ap_rputs("  the name of the VirtualHost); <STRONG>DIR()</STRONG>\n", r);
   ap_rputs("  indicates a location in the URL or filesystem\n", r);
   ap_rputs("  namespace.\n", r);
   ap_rputs("  </P>\n", r);
   ap_rprintf(r, "  <H2>Startup callbacks so far:</H2>\n  <OL>\n%s  </OL>\n",
              trace);
   ap_rputs("  <H2>Connection-specific callbacks so far:</H2>\n", r);
   
  
   ap_rputs("  <H2>Request-specific callbacks so far:</H2>\n", r);
   ap_rprintf(r, "  <OL>\n%s  </OL>\n", apr_table_get(r->notes, TRACE_NOTE));
   ap_rputs("  <H2>Environment for <EM>this</EM> call:</H2>\n", r);
   ap_rputs("  <UL>\n", r);
   ap_rputs("  </UL>\n", r);
   ap_rputs(" </BODY>\n", r);
   ap_rputs("</HTML>\n", r);
   
   
    ap_rprintf(r, "Query : %s", query);
    ap_rprintf(r, "<HTML>\n<HEAD>\n\t<TITLE>__MODULE-NAME__</TITLE>\n</HEAD><BODY>\n\t<H2>__MODULE-NAME__ Request Dump</H2>\n<UL>");
    ap_rprintf(r, "\n\t<LI>Handler: %s</LI>\nMethod: %s</LI>\n\t<LI>Path Info: %s</LI>\n\t<LI>Filename: %s</LI>\n\t<LI>Protocol: %s</LI>\n\t<LI>URI: %s</LI>\n\t<LI>Hostname: %s</LI>\n\t<LI>Query: %s</LI>\n</UL>\n</BODY>\n</HTML>", r->handler, r->method, r->path_info, r->filename, r->protocol, r->uri, r->hostname, query);
    
    return OK;
}

/* POST */
static int post_handler(request_rec *r)
{
    return OK;
}

/* PUT */
static int put_handler(request_rec *r)
{
    return OK;
}

/* DELETE */
static int delete_handler(request_rec *r)
{
    return OK;
}


/*
 *  the module registration phase
 */

/* This routine is used to actually process the connection that was received.
 * Only protocol modules should implement this hook, as it gives them an
 * opportunity to replace the standard HTTP processing with processing for
 * some other protocol.  Both echo and POP3 modules are available as
 * examples.
 *
 * This is a RUN_FIRST hook.
 */
static int __NAME___process_connection(conn_rec *c)
{
    
    trace_connection(c, "x_process_connection()");
    return OK;
    
}


static void __NAME___register_hooks(apr_pool_t *p)
{
    ap_hook_process_connection(__NAME___process_connection, NULL, NULL, APR_HOOK_MIDDLE);
  
}

/*
 * Dispatch list for API hooks
 */

AP_DECLARE_MODULE(__NAME__) = {
    STANDARD20_MODULE_STUFF,
    NULL,                    /* create per-dir    config structures */
    NULL,                    /* merge  per-dir    config structures */
    NULL,                    /* create per-server config structures */
    NULL,                    /* merge  per-server config structures */
    NULL,                    /* table of config file commands	    */
    __NAME___register_hooks, /* register hooks                      */
};
